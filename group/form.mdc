---
description: 
globs: 
alwaysApply: false
---
# Form Components Rule

## Description
This rule provides guidance for implementing forms using DigitalTolk UI form components. It covers form structure, validation, state management, and best practices.

## Available Form Components

### Input Components
- BaseTextField - Text input component with validation support
- BaseInputNumber - Numeric input component with increment/decrement controls
- BaseSelect - Dropdown selection component with single and multiple selection modes
- BaseAutoComplete - Auto-complete text input with suggestions
- BaseLocationField - Location input component with map integration
- BaseTextEditor - Rich text editor component

### Selection Components
- BaseCheckbox - Checkbox input component for boolean selections
- BaseCheckboxGroup - Group component for managing multiple related checkboxes
- BaseRadio - Radio button input component for single selections
- BaseRadioGroup - Group component for managing related radio buttons
- BaseSwitch - Toggle switch component for boolean settings
- BaseRate - Rating component for user feedback

### Container Components
- BaseForm - Container component with validation handling for form elements

## Implementation Guidelines

### 1. Form Structure
```jsx
import { BaseForm } from '@digitaltolk/ui';

const MyForm = () => {
  return (
    <BaseForm
      layout="vertical"
      onFinish={handleSubmit}
      initialValues={initialData}
    >
      {/* Form fields */}
    </BaseForm>
  );
};
```

### 2. Form Fields
```jsx
// Text Input
<BaseTextField
  name="username"
  label="Username"
  required
  rules={[
    { required: true, message: 'Please enter username' },
    { min: 3, message: 'Username must be at least 3 characters' }
  ]}
/>

// Select
<BaseSelect
  name="country"
  label="Country"
  options={countryOptions}
  required
/>

// Checkbox Group
<BaseCheckboxGroup
  name="interests"
  label="Interests"
  options={interestOptions}
/>

// Switch
<BaseSwitch
  name="notifications"
  label="Enable Notifications"
  defaultChecked
/>
```

### 3. Form Validation
```jsx
const validationRules = {
  email: [
    { required: true, message: 'Email is required' },
    { type: 'email', message: 'Invalid email format' }
  ],
  password: [
    { required: true, message: 'Password is required' },
    { min: 8, message: 'Password must be at least 8 characters' }
  ]
};
```

### 4. Form Submission
```jsx
const handleSubmit = async (values) => {
  try {
    await submitForm(values);
    BaseToaster.success('Form submitted successfully');
  } catch (error) {
    BaseToaster.error('Failed to submit form');
  }
};
```

## Best Practices

### 1. Form Layout
- Use consistent spacing between fields
- Group related fields together
- Use appropriate field sizes
- Implement responsive layouts

### 2. Validation
- Implement client-side validation
- Show clear error messages
- Validate on blur and submit
- Use appropriate validation rules

### 3. State Management
- Handle loading states
- Manage form errors
- Implement field-level validation
- Track form dirty state

### 4. Accessibility
- Use proper labels
- Implement keyboard navigation
- Add ARIA attributes
- Ensure proper focus management

### 5. Performance
- Debounce input handlers
- Optimize re-renders
- Use proper key props
- Implement proper cleanup

## Common Patterns

### 1. Dynamic Forms
```jsx
const DynamicForm = () => {
  const [fields, setFields] = useState([]);

  return (
    <BaseForm>
      {fields.map((field, index) => (
        <BaseTextField
          key={field.id}
          name={`field-${index}`}
          label={field.label}
        />
      ))}
      <BaseButton onClick={() => addField()}>Add Field</BaseButton>
    </BaseForm>
  );
};
```

### 2. Form with Location Field
```jsx
const FormWithLocation = () => {
  return (
    <BaseForm>
      <BaseLocationField
        name="address"
        label="Address"
        required
        onLocationSelect={handleLocationSelect}
      />
    </BaseForm>
  );
};
```

### 3. Form with Autocomplete
```jsx
const FormWithAutocomplete = () => {
  return (
    <BaseForm>
      <BaseAutoComplete
        name="skill"
        label="Skills"
        options={skillOptions}
        filterOption={(input, option) =>
          option.label.toLowerCase().indexOf(input.toLowerCase()) >= 0
        }
      />
    </BaseForm>
  );
};
```

### 4. Form with Conditional Fields
```jsx
const ConditionalForm = () => {
  const [showAdditionalField, setShowAdditionalField] = useState(false);
  
  return (
    <BaseForm>
      <BaseSwitch
        name="enableFeature"
        label="Enable Feature"
        onChange={(checked) => setShowAdditionalField(checked)}
      />
      
      {showAdditionalField && (
        <BaseTextField
          name="featureConfig"
          label="Feature Configuration"
        />
      )}
    </BaseForm>
  );
};
```

## Error Handling

### 1. Form Level Errors
```jsx
<BaseForm
  onFinishFailed={({ errorFields }) => {
    BaseToaster.error('Please fix the errors in the form');
  }}
>
  {/* Form fields */}
</BaseForm>
```

### 2. Field Level Errors
```jsx
<BaseTextField
  name="email"
  validateStatus={errors.email ? 'error' : ''}
  help={errors.email}
/>
```

## Testing Checklist

- [ ] Form submission works correctly
- [ ] Validation rules are enforced
- [ ] Error messages are displayed properly
- [ ] Form state is managed correctly
- [ ] Form is accessible
- [ ] Form is responsive
- [ ] Form handles errors gracefully
- [ ] Form can be reset
- [ ] Form maintains state on navigation
- [ ] Conditional fields work correctly

## Notes
- Always use the BaseForm component as the form container
- Implement proper error handling
- Use appropriate validation rules
- Follow the design system guidelines
- Test all form scenarios
- Ensure accessibility compliance

---
description: 
globs: 
alwaysApply: false
---
# Capacitor Push Notifications Plugin
---
description: Guide for implementing push notifications with Capacitor
glob: "**/*{notification,push}*.{ts,js,vue}"
---

## Overview

The Push Notifications plugin enables your application to receive push notifications on iOS and Android devices. This guide covers setup, configuration, and implementation of push notifications in your Capacitor app.

## Installation

```bash
npm install @capacitor/push-notifications
npx cap sync
```

## iOS Configuration

### Step 1: Enable Push Notification Capability

1. Open your project in Xcode with `npx cap open ios`
2. Select your app target
3. Go to "Signing & Capabilities"
4. Click "+" to add a capability
5. Select "Push Notifications"

### Step 2: Configure Apple Developer Account

1. Log in to your Apple Developer account
2. Create an App ID with push notification capability
3. Create a push notification authentication key (or certificate)
4. Note your Team ID, Key ID, and download the p8 key file

### Step 3: Configure Info.plist

No specific entries needed for Info.plist, but ensure your app has proper entitlements.

## Android Configuration

### Step 1: Set up Firebase Project

1. Go to the [Firebase Console](mdc:https:/console.firebase.google.com)
2. Create a new project or select an existing one
3. Add an Android app to your project
   - Use your app's package name as listed in your `capacitor.config.ts`
4. Download the `google-services.json` file

### Step 2: Add Firebase Configuration

1. Place the `google-services.json` file in `android/app/`
2. Add the Google services plugin to your project-level `build.gradle`:

```groovy
// android/build.gradle
buildscript {
    repositories {
        google()
        // ...
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:x.x.x'
        classpath 'com.google.gms:google-services:4.3.10'  // Add this line
    }
}
```

3. Apply the plugin in your app-level `build.gradle`:

```groovy
// android/app/build.gradle
plugins {
    id 'com.android.application'
    id 'com.google.gms.google-services'  // Add this line
}
```

### Step 3: Update Your Android Manifest

Add these permissions to your `AndroidManifest.xml`:

```xml
<manifest>
    <!-- ... -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <!-- ... -->
</manifest>
```

## Capacitor Configuration

Add push notification configuration to your `capacitor.config.ts`:

```typescript
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  // ... other config
  plugins: {
    // ... other plugins
    PushNotifications: {
      presentationOptions: ["badge", "sound", "alert"]
    }
  }
};

export default config;
```

## Basic Implementation

### Requesting Permission and Registering for Push Notifications

```typescript
import { PushNotifications } from '@capacitor/push-notifications';

// Request permission to use push notifications
// iOS will prompt user and return if they granted permission or not
// Android will just grant without prompting
async function registerPushNotifications() {
  try {
    // Request permission
    const permission = await PushNotifications.requestPermissions();
    
    if (permission.receive !== 'granted') {
      // Handle permission denial
      console.log('Push notification permission denied');
      return false;
    }
    
    // Register with FCM/APNS
    await PushNotifications.register();
    
    // Setup event listeners
    setupPushListeners();
    
    return true;
  } catch (error) {
    console.error('Error registering for push:', error);
    return false;
  }
}

function setupPushListeners() {
  // Registration success event
  PushNotifications.addListener('registration', (token) => {
    console.log('Push registration success, token:', token.value);
    // Send token to backend
    sendTokenToServer(token.value);
  });
  
  // Registration error event
  PushNotifications.addListener('registrationError', (error) => {
    console.error('Error on registration:', error);
  });
  
  // Push notification received in foreground
  PushNotifications.addListener('pushNotificationReceived', (notification) => {
    console.log('Push notification received:', notification);
    // Handle notification in foreground
    handleForegroundNotification(notification);
  });
  
  // Push notification action performed (clicked)
  PushNotifications.addListener('pushNotificationActionPerformed', (action) => {
    console.log('Push notification action performed:', action);
    // Handle notification click
    handleNotificationClick(action);
  });
}

// Send device token to your server
async function sendTokenToServer(token) {
  try {
    const response = await fetch('https://your-api.com/register-device', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        token,
        platform: getPlatform(),  // 'ios' or 'android'
        userId: getUserId() // Your app's user ID
      })
    });
    
    const result = await response.json();
    console.log('Token registered with server:', result);
  } catch (error) {
    console.error('Failed to register token with server:', error);
  }
}

// Get the current platform
function getPlatform() {
  if (/(ios)/i.test(navigator.userAgent)) {
    return 'ios';
  }
  return 'android';
}
```

### Using in a Vue Component

```vue
<template>
  <div class="notifications-settings">
    <h2>Push Notifications</h2>
    
    <div v-if="loading" class="loading">
      Setting up notifications...
    </div>
    
    <div v-else>
      <p v-if="error" class="error">{{ error }}</p>
      
      <p v-if="permissionStatus">
        Current status: {{ permissionStatus }}
      </p>
      
      <button 
        @click="setupPushNotifications" 
        :disabled="loading || permissionStatus === 'granted'"
      >
        {{ permissionStatus === 'granted' ? 'Notifications Enabled' : 'Enable Notifications' }}
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { PushNotifications } from '@capacitor/push-notifications';

const permissionStatus = ref(null);
const loading = ref(false);
const error = ref(null);

onMounted(async () => {
  try {
    const status = await PushNotifications.checkPermissions();
    permissionStatus.value = status.receive;
    
    if (status.receive === 'granted') {
      // Already have permission, so initialize
      setupListeners();
      await PushNotifications.register();
    }
  } catch (err) {
    console.error('Error checking push permission:', err);
  }
});

async function setupPushNotifications() {
  loading.value = true;
  error.value = null;
  
  try {
    // Request permission
    const permission = await PushNotifications.requestPermissions();
    permissionStatus.value = permission.receive;
    
    if (permission.receive === 'granted') {
      setupListeners();
      await PushNotifications.register();
    } else {
      error.value = 'Push notification permission was denied';
    }
  } catch (err) {
    error.value = 'Failed to set up notifications: ' + err.message;
    console.error('Push notification setup error:', err);
  } finally {
    loading.value = false;
  }
}

function setupListeners() {
  // Registration success handler
  PushNotifications.addListener('registration', (token) => {
    console.log('Push token:', token.value);
    // Send token to your backend
  });
  
  // Registration error handler
  PushNotifications.addListener('registrationError', (error) => {
    console.error('Registration error:', error);
    error.value = 'Failed to register for push notifications';
  });
  
  // Foreground notification handler
  PushNotifications.addListener('pushNotificationReceived', (notification) => {
    console.log('Notification received:', notification);
    // Handle the notification in the foreground
    // For example, show a custom notification UI
  });
  
  // Notification click handler
  PushNotifications.addListener('pushNotificationActionPerformed', (action) => {
    console.log('Action performed:', action);
    // Handle notification click
    // For example, navigate to a specific screen
  });
}
</script>
```

## Server-Side Implementation

### Firebase Cloud Messaging (Android)

Example using Firebase Admin SDK (Node.js):

```javascript
// Firebase Admin setup (server-side)
const admin = require('firebase-admin');
const serviceAccount = require('./path-to-service-account.json');

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount)
});

// Function to send notification to single device
async function sendPushNotification(token, title, body, data = {}) {
  try {
    const message = {
      token: token, // The FCM token of the device
      notification: {
        title: title,
        body: body
      },
      data: data, // Optional data payload
      android: {
        notification: {
          icon: 'ic_notification',
          color: '#4CAF50',
          sound: 'default',
          channelId: 'default-channel'
        }
      }
    };
    
    const response = await admin.messaging().send(message);
    console.log('Successfully sent message:', response);
    return response;
  } catch (error) {
    console.error('Error sending message:', error);
    throw error;
  }
}

// Send to multiple devices
async function sendPushNotificationToMultipleDevices(tokens, title, body, data = {}) {
  try {
    const message = {
      tokens: tokens, // Array of FCM tokens
      notification: {
        title: title,
        body: body
      },
      data: data,
      android: {
        notification: {
          icon: 'ic_notification',
          color: '#4CAF50'
        }
      }
    };
    
    const response = await admin.messaging().sendMulticast(message);
    console.log(`${response.successCount} messages were sent successfully`);
    return response;
  } catch (error) {
    console.error('Error sending multicast message:', error);
    throw error;
  }
}
```

### Apple Push Notification Service (iOS)

Example using `apn` node module:

```javascript
// APN setup (server-side)
const apn = require('apn');

function setupAPNProvider() {
  const options = {
    token: {
      key: './path/to/apn-key.p8', // Path to your p8 file
      keyId: 'KEY_ID', // Your Key ID from Apple Developer account
      teamId: 'TEAM_ID', // Your Team ID from Apple Developer account
    },
    production: false // Set to true for production environment
  };
  
  return new apn.Provider(options);
}

// Send notification to iOS device
async function sendAPNNotification(deviceToken, title, body, payload = {}) {
  const provider = setupAPNProvider();
  
  // Create notification
  const notification = new apn.Notification();
  notification.expiry = Math.floor(Date.now() / 1000) + 3600; // 1 hour
  notification.badge = 1;
  notification.sound = 'ping.aiff';
  notification.alert = {
    title: title,
    body: body
  };
  notification.payload = payload;
  notification.topic = 'com.your.app.bundle.id'; // Your app bundle ID
  
  try {
    const result = await provider.send(notification, deviceToken);
    console.log('APN sent:', result);
    
    provider.shutdown();
    return result;
  } catch (error) {
    console.error('APN send error:', error);
    provider.shutdown();
    throw error;
  }
}
```

## Advanced Features

### Handling Notification Data

Structure your notification data for consistent handling across platforms:

```typescript
// Notification data structure
interface PushNotificationData {
  type: string;  // 'message', 'alert', etc.
  id: string;    // Unique ID for this notification
  entityId?: string; // ID of the related entity
  route?: string;    // App route to navigate to
  [key: string]: any; // Any other custom data
}

// Example handler function
function handleNotificationData(data: PushNotificationData) {
  switch (data.type) {
    case 'message':
      // Handle new message notification
      navigateToChat(data.entityId);
      break;
    case 'alert':
      // Handle alert notification
      showAlert(data);
      break;
    case 'update':
      // Handle update notification
      refreshData();
      break;
    default:
      // Default handling
      console.log('Received notification:', data);
  }
}
```

### Notification Channels (Android)

Configure notification channels in your MainActivity.java:

```java
// android/app/src/main/java/your/app/package/MainActivity.java

package your.app.package;

import android.os.Bundle;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.Context;
import android.os.Build;
import com.getcapacitor.BridgeActivity;

public class MainActivity extends BridgeActivity {
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    
    // Register notification channels for Android 8+
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      createNotificationChannel("important", "Important Notifications", 
                               "High priority notifications", NotificationManager.IMPORTANCE_HIGH);
      
      createNotificationChannel("default", "Default Notifications", 
                               "Regular notifications", NotificationManager.IMPORTANCE_DEFAULT);
      
      createNotificationChannel("marketing", "Marketing", 
                               "Promotional notifications", NotificationManager.IMPORTANCE_LOW);
    }
  }
  
  private void createNotificationChannel(String id, String name, String description, int importance) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      NotificationChannel channel = new NotificationChannel(id, name, importance);
      channel.setDescription(description);
      
      NotificationManager notificationManager = getSystemService(NotificationManager.class);
      notificationManager.createNotificationChannel(channel);
    }
  }
}
```

### Rich Notifications (iOS)

Set up a Notification Service Extension for iOS:

1. In Xcode, go to File > New > Target
2. Choose "Notification Service Extension"
3. Name it and configure it
4. Implement the code to handle rich notifications

```swift
// NotificationService.swift
import UserNotifications

class NotificationService: UNNotificationServiceExtension {
    var contentHandler: ((UNNotificationContent) -> Void)?
    var bestAttemptContent: UNMutableNotificationContent?

    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {
        self.contentHandler = contentHandler
        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
        
        guard let bestAttemptContent = bestAttemptContent else { return }
        
        // Process the notification content here
        // For example, download images, modify text, etc.
        
        // Check if there's an attachment URL
        guard let attachmentURLString = request.content.userInfo["attachment-url"] as? String,
              let attachmentURL = URL(string: attachmentURLString) else {
            contentHandler(bestAttemptContent)
            return
        }
        
        // Download the attachment
        downloadAttachment(from: attachmentURL) { (attachment) in
            if let attachment = attachment {
                bestAttemptContent.attachments = [attachment]
            }
            
            contentHandler(bestAttemptContent)
        }
    }
    
    override func serviceExtensionTimeWillExpire() {
        // Called just before the extension will be terminated by the system
        if let contentHandler = contentHandler, let bestAttemptContent = bestAttemptContent {
            contentHandler(bestAttemptContent)
        }
    }
    
    private func downloadAttachment(from url: URL, completionHandler: @escaping (UNNotificationAttachment?) -> Void) {
        let session = URLSession(configuration: .default)
        let task = session.dataTask(with: url) { (data, response, error) in
            if let error = error {
                print("Error downloading attachment: \(error)")
                completionHandler(nil)
                return
            }
            
            guard let data = data else {
                completionHandler(nil)
                return
            }
            
            let fileManager = FileManager.default
            let tempDirectory = URL(fileURLWithPath: NSTemporaryDirectory())
            let fileIdentifier = UUID().uuidString
            let fileURL = tempDirectory.appendingPathComponent(fileIdentifier).appendingPathExtension("jpg")
            
            do {
                try data.write(to: fileURL)
                let attachment = try UNNotificationAttachment(identifier: fileIdentifier, url: fileURL, options: nil)
                completionHandler(attachment)
            } catch {
                print("Error creating attachment: \(error)")
                completionHandler(nil)
            }
        }
        
        task.resume()
    }
}
```

## Creating a Reusable Composable

```typescript
// composables/usePushNotifications.ts
import { ref, onMounted, onUnmounted } from 'vue';
import { PushNotifications } from '@capacitor/push-notifications';
import { Capacitor } from '@capacitor/core';

export function usePushNotifications() {
  const permissionStatus = ref(null);
  const token = ref(null);
  const loading = ref(false);
  const error = ref(null);
  const lastNotification = ref(null);
  
  // Event listeners tracking for cleanup
  let listeners = [];
  
  onMounted(async () => {
    // Only proceed on native platforms
    if (Capacitor.isNativePlatform()) {
      await checkPermissions();
    }
  });
  
  onUnmounted(() => {
    // Clean up listeners on component unmount
    removeAllListeners();
  });
  
  async function checkPermissions() {
    try {
      const status = await PushNotifications.checkPermissions();
      permissionStatus.value = status.receive;
      return status.receive;
    } catch (err) {
      console.error('Error checking push permissions:', err);
      error.value = err.message;
      return 'prompt';
    }
  }
  
  async function requestPermissions() {
    loading.value = true;
    error.value = null;
    
    try {
      const permission = await PushNotifications.requestPermissions();
      permissionStatus.value = permission.receive;
      
      if (permission.receive === 'granted') {
        await registerForPush();
      }
      
      return permission.receive;
    } catch (err) {
      console.error('Error requesting permissions:', err);
      error.value = err.message;
      return 'denied';
    } finally {
      loading.value = false;
    }
  }
  
  async function registerForPush() {
    if (!Capacitor.isNativePlatform()) {
      return false;
    }
    
    try {
      setupListeners();
      await PushNotifications.register();
      return true;
    } catch (err) {
      console.error('Error registering for push:', err);
      error.value = err.message;
      return false;
    }
  }
  
  function setupListeners() {
    const registrationListener = PushNotifications.addListener('registration', (result) => {
      token.value = result.value;
      // You might want to emit an event or call a function to send this token to your server
    });
    
    const errorListener = PushNotifications.addListener('registrationError', (err) => {
      console.error('Registration error:', err);
      error.value = 'Failed to register for push notifications';
    });
    
    const receiveListener = PushNotifications.addListener('pushNotificationReceived', (notification) => {
      console.log('Notification received:', notification);
      lastNotification.value = notification;
      // Process the notification, e.g., show a toast or update UI
    });
    
    const actionListener = PushNotifications.addListener('pushNotificationActionPerformed', (action) => {
      console.log('Notification action performed:', action);
      lastNotification.value = action.notification;
      // Handle the action, e.g., navigate to a specific page
    });
    
    // Track listeners for cleanup
    listeners = [registrationListener, errorListener, receiveListener, actionListener];
  }
  
  function removeAllListeners() {
    listeners.forEach(listener => {
      listener.remove();
    });
    listeners = [];
  }
  
  // Get all delivered notifications
  async function getDeliveredNotifications() {
    try {
      const result = await PushNotifications.getDeliveredNotifications();
      return result.notifications;
    } catch (err) {
      console.error('Error getting delivered notifications:', err);
      error.value = err.message;
      return [];
    }
  }
  
  // Remove all delivered notifications
  async function removeAllDeliveredNotifications() {
    try {
      await PushNotifications.removeAllDeliveredNotifications();
      return true;
    } catch (err) {
      console.error('Error removing delivered notifications:', err);
      error.value = err.message;
      return false;
    }
  }
  
  return {
    permissionStatus,
    token,
    loading,
    error,
    lastNotification,
    checkPermissions,
    requestPermissions,
    registerForPush,
    getDeliveredNotifications,
    removeAllDeliveredNotifications
  };
}
```

## Best Practices

1. **Permission Handling**
   - Always request permission before registering for push notifications
   - Explain clearly why your app needs push notifications
   - Provide alternative notification methods if permission is denied

2. **Token Management**
   - Store device tokens securely in your backend
   - Update tokens when they change
   - Clean up invalid tokens based on feedback from push services

3. **Notification Content**
   - Keep notification titles and bodies concise and clear
   - Include action buttons when appropriate
   - Consider localization for international users

4. **User Experience**
   - Don't overwhelm users with too many notifications
   - Allow users to customize notification preferences
   - Respect notification settings set by the user

5. **Testing**
   - Test notifications on real devices, not just emulators
   - Test both foreground and background states
   - Test notification tapping and action handling

6. **Security**
   - Keep your push notification service credentials secure
   - Validate notification data on the client side
   - Don't include sensitive information in notification payloads

7. **Debugging**
   - Set up proper logging for notification events
   - Handle errors gracefully and provide feedback
   - Use Firebase Console (Android) and Apple Developer Console (iOS) for testing

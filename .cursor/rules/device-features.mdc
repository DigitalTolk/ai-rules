---
description: 
globs: 
alwaysApply: false
---
# Device Features
---
description: Guidelines for implementing device-specific features using Capacitor
glob: "**/device/**/*.{js,ts}"
---

## Overview

Device features refer to platform-specific capabilities available on mobile devices, such as camera, geolocation, notifications, and biometrics. This document outlines our conventions for implementing and using device features in mobile applications built with Capacitor.

## Directory Structure

Device-related functionality is organized in the following structure:

```
/utils/device
  /camera.ts              # Camera and photo functionality
  /geolocation.ts         # Location services
  /notifications.ts       # Push and local notifications
  /storage.ts             # Device storage utilities
  /biometrics.ts          # Fingerprint and face recognition
  /network.ts             # Network connectivity
  /battery.ts             # Battery status
  /device-info.ts         # Device information
  /file-system.ts         # File system access
  /haptics.ts             # Haptic feedback
```

## Feature Implementation

Each device feature should be implemented as a standalone module with a clean API that abstracts the underlying Capacitor plugin implementation.

### Camera Implementation

```ts
// utils/device/camera.ts
import { Camera, CameraResultType, CameraSource, Photo } from '@capacitor/camera'
import { ref } from 'vue'

export interface CameraOptions {
  quality?: number
  allowEditing?: boolean
  source?: 'camera' | 'photos' | 'prompt'
  resultType?: 'base64' | 'dataUrl' | 'uri'
}

export function useCamera() {
  const lastPhoto = ref<Photo | null>(null)
  const isAvailable = ref(true)
  const isLoading = ref(false)
  const error = ref<string | null>(null)

  // Check if camera is available
  const checkAvailability = async (): Promise<boolean> => {
    try {
      const permission = await Camera.checkPermissions()
      isAvailable.value = permission.camera === 'granted' || permission.camera === 'prompt'
      return isAvailable.value
    } catch (err) {
      isAvailable.value = false
      error.value = 'Camera not available on this device'
      return false
    }
  }

  // Request permission
  const requestPermission = async (): Promise<boolean> => {
    try {
      const permission = await Camera.requestPermissions()
      isAvailable.value = permission.camera === 'granted'
      return isAvailable.value
    } catch (err) {
      error.value = 'Camera permission denied'
      return false
    }
  }

  // Take a photo
  const takePhoto = async (options: CameraOptions = {}): Promise<Photo | null> => {
    error.value = null
    
    if (!(await checkAvailability())) {
      if (!(await requestPermission())) {
        return null
      }
    }
    
    isLoading.value = true
    
    try {
      const result = await Camera.getPhoto({
        quality: options.quality ?? 90,
        allowEditing: options.allowEditing ?? true,
        source: mapCameraSource(options.source),
        resultType: mapResultType(options.resultType),
      })
      
      lastPhoto.value = result
      return result
    } catch (err) {
      if (err.message !== 'User cancelled photo selection') {
        error.value = 'Error capturing photo: ' + err.message
      }
      return null
    } finally {
      isLoading.value = false
    }
  }
  
  // Helper functions to map options
  const mapCameraSource = (source?: string): CameraSource => {
    switch (source) {
      case 'camera': return CameraSource.Camera
      case 'photos': return CameraSource.Photos
      default: return CameraSource.Prompt
    }
  }
  
  const mapResultType = (resultType?: string): CameraResultType => {
    switch (resultType) {
      case 'base64': return CameraResultType.Base64
      case 'dataUrl': return CameraResultType.DataUrl
      default: return CameraResultType.Uri
    }
  }

  return {
    takePhoto,
    lastPhoto,
    isAvailable,
    isLoading,
    error,
    checkAvailability,
    requestPermission
  }
}
```

### Geolocation Implementation

```ts
// utils/device/geolocation.ts
import { Geolocation, Position, PermissionStatus } from '@capacitor/geolocation'
import { ref, onUnmounted } from 'vue'

export interface LocationOptions {
  enableHighAccuracy?: boolean
  timeout?: number
  maximumAge?: number
}

export function useGeolocation() {
  const currentPosition = ref<Position | null>(null)
  const watchId = ref<string | null>(null)
  const isTracking = ref(false)
  const isAvailable = ref(true)
  const error = ref<string | null>(null)
  const isLoading = ref(false)
  
  // Check if location services are available
  const checkPermission = async (): Promise<boolean> => {
    try {
      const status: PermissionStatus = await Geolocation.checkPermissions()
      isAvailable.value = status.location === 'granted' || status.location === 'prompt'
      return isAvailable.value
    } catch (err) {
      isAvailable.value = false
      error.value = 'Location services not available'
      return false
    }
  }
  
  // Request location permission
  const requestPermission = async (): Promise<boolean> => {
    try {
      const status = await Geolocation.requestPermissions()
      isAvailable.value = status.location === 'granted'
      return isAvailable.value
    } catch (err) {
      error.value = 'Location permission denied'
      return false
    }
  }
  
  // Get current position
  const getCurrentPosition = async (options: LocationOptions = {}): Promise<Position | null> => {
    error.value = null
    
    if (!(await checkPermission())) {
      if (!(await requestPermission())) {
        return null
      }
    }
    
    isLoading.value = true
    
    try {
      const position = await Geolocation.getCurrentPosition({
        enableHighAccuracy: options.enableHighAccuracy ?? true,
        timeout: options.timeout ?? 10000,
        maximumAge: options.maximumAge ?? 0
      })
      
      currentPosition.value = position
      return position
    } catch (err) {
      error.value = 'Error getting location: ' + err.message
      return null
    } finally {
      isLoading.value = false
    }
  }
  
  // Watch position
  const startTracking = async (options: LocationOptions = {}): Promise<boolean> => {
    if (isTracking.value) return true
    
    if (!(await checkPermission())) {
      if (!(await requestPermission())) {
        return false
      }
    }
    
    try {
      watchId.value = await Geolocation.watchPosition(
        {
          enableHighAccuracy: options.enableHighAccuracy ?? true,
          timeout: options.timeout ?? 10000,
          maximumAge: options.maximumAge ?? 0
        },
        (position) => {
          currentPosition.value = position
        }
      )
      
      isTracking.value = true
      return true
    } catch (err) {
      error.value = 'Error tracking location: ' + err.message
      return false
    }
  }
  
  // Stop watching position
  const stopTracking = async (): Promise<void> => {
    if (watchId.value) {
      await Geolocation.clearWatch({ id: watchId.value })
      watchId.value = null
      isTracking.value = false
    }
  }
  
  // Clean up on component unmount
  onUnmounted(() => {
    if (isTracking.value) {
      stopTracking()
    }
  })
  
  return {
    currentPosition,
    isTracking,
    isAvailable,
    isLoading,
    error,
    getCurrentPosition,
    startTracking,
    stopTracking,
    checkPermission,
    requestPermission
  }
}
```

## Using Device Features in Components

Access device features through the utility modules in your components:

```vue
<script setup>
import { ref } from 'vue'
import { useCamera } from '~/utils/device/camera'
import { useGeolocation } from '~/utils/device/geolocation'

// Initialize camera
const { takePhoto, lastPhoto, isLoading: cameraLoading, error: cameraError } = useCamera()

// Initialize geolocation
const { getCurrentPosition, currentPosition, error: locationError } = useGeolocation()

// References to store data
const photoPreview = ref(null)
const locationInfo = ref(null)

// Take a photo
const handleTakePhoto = async () => {
  const photo = await takePhoto({ allowEditing: true, source: 'camera' })
  if (photo) {
    photoPreview.value = photo.webPath
  }
}

// Get current location
const handleGetLocation = async () => {
  const position = await getCurrentPosition()
  if (position) {
    locationInfo.value = {
      latitude: position.coords.latitude,
      longitude: position.coords.longitude,
      accuracy: position.coords.accuracy
    }
  }
}
</script>

<template>
  <div>
    <h2>Device Features Demo</h2>
    
    <!-- Camera Section -->
    <div class="section">
      <h3>Camera</h3>
      <button @click="handleTakePhoto" :disabled="cameraLoading">
        {{ cameraLoading ? 'Taking Photo...' : 'Take Photo' }}
      </button>
      <p v-if="cameraError" class="error">{{ cameraError }}</p>
      <div v-if="photoPreview" class="preview">
        <img :src="photoPreview" alt="Captured photo" />
      </div>
    </div>
    
    <!-- Geolocation Section -->
    <div class="section">
      <h3>Geolocation</h3>
      <button @click="handleGetLocation">Get Current Location</button>
      <p v-if="locationError" class="error">{{ locationError }}</p>
      <div v-if="locationInfo" class="info">
        <p>Latitude: {{ locationInfo.latitude }}</p>
        <p>Longitude: {{ locationInfo.longitude }}</p>
        <p>Accuracy: {{ locationInfo.accuracy }} meters</p>
      </div>
    </div>
  </div>
</template>
```

## Platform Considerations

### iOS-Specific Configuration

For iOS, add required usage descriptions in `capacitor.config.ts` or directly in `Info.plist`:

```ts
// capacitor.config.ts
const config: CapacitorConfig = {
  // ... other config
  ios: {
    infoPlist: {
      NSCameraUsageDescription: "This app needs camera access to take photos",
      NSLocationWhenInUseUsageDescription: "This app needs location access to provide location-based features",
      NSPhotoLibraryUsageDescription: "This app needs photo library access to select photos",
      NSFaceIDUsageDescription: "This app uses Face ID for secure authentication"
    }
  }
}
```

### Android-Specific Configuration

For Android, add required permissions in `capacitor.config.ts` or directly in `AndroidManifest.xml`:

```ts
// capacitor.config.ts
const config: CapacitorConfig = {
  // ... other config
  android: {
    permissions: [
      "android.permission.CAMERA",
      "android.permission.READ_EXTERNAL_STORAGE",
      "android.permission.WRITE_EXTERNAL_STORAGE",
      "android.permission.ACCESS_COARSE_LOCATION",
      "android.permission.ACCESS_FINE_LOCATION"
    ]
  }
}
```

## Error Handling and Fallbacks

Always implement proper error handling and fallbacks for device features:

```ts
// Example of implementing a fallback for camera
async function captureImageWithFallback() {
  try {
    // Try to use device camera
    const photo = await takePhoto()
    return photo
  } catch (error) {
    // If camera fails, fallback to file input
    console.warn('Camera failed, falling back to file input:', error)
    return new Promise((resolve) => {
      const input = document.createElement('input')
      input.type = 'file'
      input.accept = 'image/*'
      input.onchange = (event) => {
        const file = event.target.files[0]
        if (file) {
          const reader = new FileReader()
          reader.onload = () => {
            resolve({
              webPath: reader.result,
              format: file.type.split('/')[1]
            })
          }
          reader.readAsDataURL(file)
        } else {
          resolve(null)
        }
      }
      input.click()
    })
  }
}
```

## Best Practices

1. **Progressive Enhancement**
   - Design features to work on web first, then enhance with native capabilities
   - Always provide fallbacks for web environments

2. **Permission Handling**
   - Always check for permissions before using device features
   - Provide clear explanations of why permissions are needed
   - Gracefully handle permission denials with informative messages

3. **Error Management**
   - Implement comprehensive error handling for all device interactions
   - Provide user-friendly error messages
   - Log detailed error information for debugging

4. **Performance**
   - Use device features efficiently to minimize battery impact
   - Release resources when not in use (stop location tracking, release camera)
   - Implement appropriate caching strategies

5. **Testing**
   - Test on real devices, not just emulators
   - Test on multiple device types and OS versions
   - Test features with permissions both granted and denied

6. **Cross-Platform Compatibility**
   - Be aware of platform-specific limitations and differences
   - Use feature detection to handle missing capabilities
   - Implement platform-specific code when necessary

# Device-Specific Features

This guide outlines best practices for implementing device-specific features and capabilities in Nuxt applications, ensuring a good user experience across different devices and platforms.

## Device Detection

### Create a Device Detection Composable

```typescript
// composables/useDevice.ts
import { ref, computed, onMounted } from 'vue'

export function useDevice() {
  // Device type
  const isMobile = ref(false)
  const isTablet = ref(false)
  const isDesktop = ref(false)
  
  // Operating system
  const isIOS = ref(false)
  const isAndroid = ref(false)
  const isMacOS = ref(false)
  const isWindows = ref(false)
  const isLinux = ref(false)
  
  // Browser
  const isSafari = ref(false)
  const isChrome = ref(false)
  const isFirefox = ref(false)
  const isEdge = ref(false)
  
  // Features
  const hasTouchScreen = ref(false)
  const hasMotionSensor = ref(false)
  const hasGeolocation = ref(false)
  const hasNotificationSupport = ref(false)
  
  // Screen
  const screenWidth = ref(0)
  const screenHeight = ref(0)
  const orientation = ref('portrait')
  
  // Connectivity
  const isOnline = ref(true)
  const connectionType = ref('unknown')
  
  // Derived properties
  const deviceType = computed(() => {
    if (isMobile.value) return 'mobile'
    if (isTablet.value) return 'tablet'
    return 'desktop'
  })
  
  // Initialize detection on client side only
  onMounted(() => {
    // Skip detection during SSR
    if (process.server) return
    
    // Device type detection
    detectDeviceType()
    
    // OS detection
    detectOperatingSystem()
    
    // Browser detection
    detectBrowser()
    
    // Features detection
    detectFeatures()
    
    // Screen properties
    detectScreenProperties()
    
    // Connectivity
    detectConnectivity()
    
    // Set up event listeners
    setupEventListeners()
  })
  
  function detectDeviceType() {
    const userAgent = navigator.userAgent
    
    // Mobile detection
    const mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i
    isMobile.value = mobileRegex.test(userAgent) && window.innerWidth < 768
    
    // Tablet detection
    isTablet.value = (
      (mobileRegex.test(userAgent) && window.innerWidth >= 768 && window.innerWidth < 1024) ||
      /iPad|Android(?!.*Mobile)/i.test(userAgent)
    )
    
    // Desktop is everything else
    isDesktop.value = !isMobile.value && !isTablet.value
  }
  
  function detectOperatingSystem() {
    const userAgent = navigator.userAgent
    
    isIOS.value = /iPhone|iPad|iPod/i.test(userAgent)
    isAndroid.value = /Android/i.test(userAgent)
    isMacOS.value = /Mac OS X/i.test(userAgent) && !isIOS.value
    isWindows.value = /Windows/i.test(userAgent)
    isLinux.value = /Linux/i.test(userAgent) && !isAndroid.value
  }
  
  function detectBrowser() {
    const userAgent = navigator.userAgent
    
    isSafari.value = /Safari/i.test(userAgent) && !/Chrome/i.test(userAgent)
    isChrome.value = /Chrome/i.test(userAgent)
    isFirefox.value = /Firefox/i.test(userAgent)
    isEdge.value = /Edg/i.test(userAgent)
  }
  
  function detectFeatures() {
    // Touch screen
    hasTouchScreen.value = 'ontouchstart' in window || navigator.maxTouchPoints > 0
    
    // Motion sensors
    hasMotionSensor.value = 'DeviceMotionEvent' in window
    
    // Geolocation
    hasGeolocation.value = 'geolocation' in navigator
    
    // Notifications
    hasNotificationSupport.value = 'Notification' in window
  }
  
  function detectScreenProperties() {
    screenWidth.value = window.innerWidth
    screenHeight.value = window.innerHeight
    orientation.value = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape'
  }
  
  function detectConnectivity() {
    isOnline.value = navigator.onLine
    
    if ('connection' in navigator && navigator.connection) {
      connectionType.value = navigator.connection.effectiveType || 'unknown'
    }
  }
  
  function setupEventListeners() {
    // Resize listener for screen properties
    window.addEventListener('resize', () => {
      screenWidth.value = window.innerWidth
      screenHeight.value = window.innerHeight
      orientation.value = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape'
      detectDeviceType()
    })
    
    // Online/offline events
    window.addEventListener('online', () => {
      isOnline.value = true
    })
    
    window.addEventListener('offline', () => {
      isOnline.value = false
    })
    
    // Orientation change
    window.addEventListener('orientationchange', () => {
      orientation.value = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape'
    })
  }
  
  return {
    // Device type
    isMobile,
    isTablet,
    isDesktop,
    deviceType,
    
    // Operating system
    isIOS,
    isAndroid,
    isMacOS,
    isWindows,
    isLinux,
    
    // Browser
    isSafari,
    isChrome,
    isFirefox,
    isEdge,
    
    // Features
    hasTouchScreen,
    hasMotionSensor,
    hasGeolocation,
    hasNotificationSupport,
    
    // Screen
    screenWidth,
    screenHeight,
    orientation,
    
    // Connectivity
    isOnline,
    connectionType
  }
}
```

## Using Device Features in Components

```vue
<template>
  <div>
    <div v-if="isMobile">
      <MobileNavigation />
    </div>
    <div v-else>
      <DesktopNavigation />
    </div>
    
    <div v-if="!isOnline" class="offline-warning">
      You are currently offline. Some features may be unavailable.
    </div>
    
    <button 
      v-if="hasGeolocation" 
      @click="requestLocation"
    >
      Get My Location
    </button>
  </div>
</template>

<script setup>
import { useDevice } from '~/composables/useDevice'
import { ref } from 'vue'

const { 
  isMobile, 
  isOnline, 
  hasGeolocation 
} = useDevice()

const userLocation = ref(null)

function requestLocation() {
  if (hasGeolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        userLocation.value = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        }
      },
      (error) => {
        console.error('Error getting location:', error)
      }
    )
  }
}
</script>
```

## Device-Specific Styles

Use CSS media queries for responsive design:

```vue
<style scoped>
.component {
  /* Default styles */
  padding: 1rem;
  font-size: 1rem;
}

/* Mobile styles */
@media (max-width: 767px) {
  .component {
    padding: 0.5rem;
    font-size: 0.875rem;
  }
}

/* Tablet styles */
@media (min-width: 768px) and (max-width: 1023px) {
  .component {
    padding: 0.75rem;
  }
}

/* Desktop styles */
@media (min-width: 1024px) {
  .component {
    padding: 1.5rem;
  }
}

/* Orientation-specific styles */
@media (orientation: landscape) {
  .component {
    display: flex;
  }
}

/* Touch device styles */
@media (hover: none) and (pointer: coarse) {
  .component {
    /* Larger touch targets */
    min-height: 44px;
  }
}

/* High-density (retina) screens */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .component {
    /* High-quality images or adjusted styles */
  }
}
</style>
```

## Device-Specific Features Implementation

### Geolocation Service

```typescript
// composables/useGeolocation.ts
import { ref, reactive } from 'vue'
import { useDevice } from './useDevice'

export function useGeolocation() {
  const { hasGeolocation } = useDevice()
  
  const location = reactive({
    latitude: null,
    longitude: null,
    accuracy: null,
    timestamp: null
  })
  
  const error = ref(null)
  const isTracking = ref(false)
  let watchId = null
  
  // Get location once
  function getCurrentPosition() {
    if (!hasGeolocation.value) {
      error.value = 'Geolocation not supported'
      return Promise.reject(error.value)
    }
    
    return new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          updatePosition(position)
          resolve(location)
        },
        (err) => {
          error.value = err.message || 'Failed to get location'
          reject(error.value)
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      )
    })
  }
  
  // Start tracking location
  function startTracking() {
    if (!hasGeolocation.value) {
      error.value = 'Geolocation not supported'
      return
    }
    
    // Clear any existing tracker
    stopTracking()
    
    isTracking.value = true
    watchId = navigator.geolocation.watchPosition(
      updatePosition,
      (err) => {
        error.value = err.message
        isTracking.value = false
      },
      {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 0
      }
    )
  }
  
  // Stop tracking
  function stopTracking() {
    if (watchId !== null) {
      navigator.geolocation.clearWatch(watchId)
      watchId = null
      isTracking.value = false
    }
  }
  
  // Update position data
  function updatePosition(position) {
    location.latitude = position.coords.latitude
    location.longitude = position.coords.longitude
    location.accuracy = position.coords.accuracy
    location.timestamp = position.timestamp
    error.value = null
  }
  
  return {
    location,
    error,
    isTracking,
    getCurrentPosition,
    startTracking,
    stopTracking
  }
}
```

### Notifications Service

```typescript
// composables/useNotifications.ts
import { ref } from 'vue'
import { useDevice } from './useDevice'

export function useNotifications() {
  const { hasNotificationSupport } = useDevice()
  
  const permissionStatus = ref('default') // 'default', 'granted', 'denied'
  const error = ref(null)
  
  // Check permission status
  function checkPermission() {
    if (!hasNotificationSupport.value) {
      permissionStatus.value = 'denied'
      error.value = 'Notifications are not supported on this device'
      return Promise.resolve('denied')
    }
    
    permissionStatus.value = Notification.permission
    return Promise.resolve(permissionStatus.value)
  }
  
  // Request permission
  async function requestPermission() {
    if (!hasNotificationSupport.value) {
      permissionStatus.value = 'denied'
      error.value = 'Notifications are not supported on this device'
      return 'denied'
    }
    
    try {
      const result = await Notification.requestPermission()
      permissionStatus.value = result
      return result
    } catch (err) {
      error.value = err.message || 'Failed to request permission'
      return 'denied'
    }
  }
  
  // Show notification
  function showNotification(title, options = {}) {
    if (!hasNotificationSupport.value || permissionStatus.value !== 'granted') {
      error.value = 'Permission not granted for notifications'
      return null
    }
    
    try {
      return new Notification(title, options)
    } catch (err) {
      error.value = err.message || 'Failed to show notification'
      return null
    }
  }
  
  // Initialize on client side
  if (process.client) {
    checkPermission()
  }
  
  return {
    permissionStatus,
    error,
    checkPermission,
    requestPermission,
    showNotification
  }
}
```

### Device Motion/Orientation

```typescript
// composables/useDeviceMotion.ts
import { reactive, ref, onMounted, onUnmounted } from 'vue'
import { useDevice } from './useDevice'

export function useDeviceMotion() {
  const { hasMotionSensor } = useDevice()
  
  const isListening = ref(false)
  const error = ref(null)
  
  // Motion data
  const motion = reactive({
    acceleration: { x: 0, y: 0, z: 0 },
    accelerationIncludingGravity: { x: 0, y: 0, z: 0 },
    rotationRate: { alpha: 0, beta: 0, gamma: 0 },
    interval: 0
  })
  
  // Orientation data
  const orientation = reactive({
    absolute: false,
    alpha: 0, // Z-axis rotation [0-360)
    beta: 0,  // X-axis rotation [-180, 180]
    gamma: 0  // Y-axis rotation [-90, 90]
  })
  
  // Start listening for motion events
  function startListening() {
    if (!hasMotionSensor.value) {
      error.value = 'Motion sensors not supported'
      return false
    }
    
    if (isListening.value) return true
    
    // Request permission if needed (iOS 13+)
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
      DeviceMotionEvent.requestPermission()
        .then(permissionState => {
          if (permissionState === 'granted') {
            attachEventListeners()
          } else {
            error.value = 'Permission denied'
          }
        })
        .catch(err => {
          error.value = err.message || 'Error requesting permission'
        })
    } else {
      // Permission not required
      attachEventListeners()
    }
    
    return isListening.value
  }
  
  // Stop listening for motion events
  function stopListening() {
    if (!isListening.value) return
    
    window.removeEventListener('devicemotion', handleMotionEvent)
    window.removeEventListener('deviceorientation', handleOrientationEvent)
    isListening.value = false
  }
  
  // Attach event listeners
  function attachEventListeners() {
    window.addEventListener('devicemotion', handleMotionEvent)
    window.addEventListener('deviceorientation', handleOrientationEvent)
    isListening.value = true
  }
  
  // Handle motion events
  function handleMotionEvent(event) {
    motion.acceleration.x = event.acceleration?.x || 0
    motion.acceleration.y = event.acceleration?.y || 0
    motion.acceleration.z = event.acceleration?.z || 0
    
    motion.accelerationIncludingGravity.x = event.accelerationIncludingGravity?.x || 0
    motion.accelerationIncludingGravity.y = event.accelerationIncludingGravity?.y || 0
    motion.accelerationIncludingGravity.z = event.accelerationIncludingGravity?.z || 0
    
    motion.rotationRate.alpha = event.rotationRate?.alpha || 0
    motion.rotationRate.beta = event.rotationRate?.beta || 0
    motion.rotationRate.gamma = event.rotationRate?.gamma || 0
    
    motion.interval = event.interval || 0
  }
  
  // Handle orientation events
  function handleOrientationEvent(event) {
    orientation.absolute = event.absolute || false
    orientation.alpha = event.alpha || 0
    orientation.beta = event.beta || 0
    orientation.gamma = event.gamma || 0
  }
  
  // Clean up
  onUnmounted(() => {
    stopListening()
  })
  
  return {
    motion,
    orientation,
    isListening,
    error,
    startListening,
    stopListening
  }
}
```

## Creating Device-Specific Components

### Touch-Optimized Components

```vue
<!-- components/device/TouchSlider.vue -->
<template>
  <div 
    class="touch-slider" 
    @touchstart="handleTouchStart" 
    @touchmove="handleTouchMove" 
    @touchend="handleTouchEnd"
  >
    <div 
      class="slider-content" 
      :style="{ transform: `translateX(${translateX}px)` }"
    >
      <slot></slot>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'
import { useDevice } from '~/composables/useDevice'

const { hasTouchScreen } = useDevice()

const props = defineProps({
  itemWidth: { type: Number, default: 300 },
  gap: { type: Number, default: 20 }
})

const translateX = ref(0)
const startX = ref(0)
const currentIndex = ref(0)
const isDragging = ref(false)

function handleTouchStart(event) {
  if (!hasTouchScreen.value) return
  
  startX.value = event.touches[0].clientX
  isDragging.value = true
}

function handleTouchMove(event) {
  if (!isDragging.value) return
  
  const currentX = event.touches[0].clientX
  const diff = currentX - startX.value
  
  // Add resistance at edges
  translateX.value = -currentIndex.value * (props.itemWidth + props.gap) + diff
}

function handleTouchEnd(event) {
  if (!isDragging.value) return
  
  isDragging.value = false
  const endX = event.changedTouches[0].clientX
  const diff = endX - startX.value
  
  // Determine if we should snap to next or previous
  if (Math.abs(diff) > props.itemWidth / 3) {
    if (diff > 0 && currentIndex.value > 0) {
      // Swipe right
      currentIndex.value--
    } else if (diff < 0) {
      // Swipe left
      currentIndex.value++
    }
  }
  
  // Snap to position
  translateX.value = -currentIndex.value * (props.itemWidth + props.gap)
}
</script>

<style scoped>
.touch-slider {
  overflow: hidden;
  width: 100%;
  touch-action: pan-x;
}

.slider-content {
  display: flex;
  gap: v-bind('props.gap + "px"');
  transition: transform 0.3s ease;
  will-change: transform;
}
</style>
```

## Best Practices

1. **Progressive Enhancement**
   - Start with a baseline experience that works for all devices
   - Enhance with device-specific features when available
   - Always provide fallbacks for unsupported features

2. **Performance Considerations**
   - Mobile devices often have less processing power and bandwidth
   - Optimize images and assets for different devices
   - Implement code splitting and lazy loading
   - Monitor battery usage for intensive features

3. **Touch Interactions**
   - Design with touch in mind for mobile/tablet
   - Use larger touch targets (min 44x44px)
   - Implement custom touch gestures thoughtfully
   - Test swipe and multi-touch interactions

4. **Testing**
   - Test on real devices, not just emulators
   - Test across different operating systems and browsers
   - Use device labs or testing services for broader coverage
   - Monitor error rates by device type

5. **Responsive Layout**
   - Use fluid layouts that adapt to different screen sizes
   - Test various screen orientations
   - Consider font size and readability on small screens
   - Design for variable viewport heights (avoid vh units on mobile)

6. **Offline Support**
   - Implement service workers for offline capabilities
   - Cache critical resources
   - Display helpful messages when offline
   - Handle reconnection gracefully

7. **Accessibility**
   - Ensure device features have accessible alternatives
   - Test with screen readers on different devices
   - Support keyboard navigation even on touch devices
   - Provide options to disable motion effects

8. **User Preferences**
   - Respect user preferences like reduced motion and dark mode
   - Allow users to enable/disable device-specific features
   - Remember user choices across sessions
   - Be transparent about capabilities being used

This guide should help you implement device-specific features effectively in your Nuxt application.

---
description: Use this rule whenever we need to manage the app's global state
globs: 
alwaysApply: false
---
# Pinia State Management
---
description: Guidelines for implementing state management with Pinia in the application
glob: "**/stores/**/*.{js,ts}"
---

## Overview

Pinia is Vue's official state management library that provides a simple and type-safe way to share state between components. This document outlines our conventions for creating and using Pinia stores in the application.

## Store Directory Structure

```
stores/
├── index.ts               # Re-exports, store setup
├── user.ts                # User store
├── auth.ts                # Authentication store
├── settings.ts            # Application settings store
└── features/              # Feature-specific stores
    ├── cart.ts            # E-commerce cart store
    └── notifications.ts   # Notifications store
```

## Store Creation Patterns

### Option Stores (Recommended)

The Options API style is more structured and often preferred for complex stores:

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import type { User } from '~/types'

interface UserState {
  currentUser: User | null
  isLoading: boolean
  error: string | null
}

export const useUserStore = defineStore('user', {
  // State
  state: (): UserState => ({
    currentUser: null,
    isLoading: false,
    error: null
  }),
  
  // Getters (computed values)
  getters: {
    isLoggedIn: (state) => !!state.currentUser,
    username: (state) => state.currentUser?.name || 'Guest',
    fullName: (state) => {
      const user = state.currentUser
      if (!user) return ''
      return `${user.firstName} ${user.lastName}`
    }
  },
  
  // Actions (methods)
  actions: {
    async fetchUser() {
      this.isLoading = true
      this.error = null
      
      try {
        const user = await $fetch('/api/user')
        this.currentUser = user
      } catch (error) {
        this.error = error.message || 'Failed to fetch user'
        console.error(error)
      } finally {
        this.isLoading = false
      }
    },
    
    logout() {
      this.currentUser = null
      // Additional logout logic
    }
  }
})
```

### Setup Stores (Alternative)

Setup stores use the Composition API style and can be more concise:

```typescript
// stores/counter.ts
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', () => {
  // State
  const count = ref(0)
  const lastUpdated = ref(new Date())
  
  // Getters
  const doubleCount = computed(() => count.value * 2)
  
  // Actions
  function increment() {
    count.value++
    lastUpdated.value = new Date()
  }
  
  function decrement() {
    count.value--
    lastUpdated.value = new Date()
  }
  
  return {
    count,
    lastUpdated,
    doubleCount,
    increment,
    decrement
  }
})
```

## Using Stores in Components

```vue
<script setup>
import { useUserStore } from '~/stores/user'

// Initialize store
const userStore = useUserStore()

// Access state and getters
const isLoggedIn = computed(() => userStore.isLoggedIn)
const username = computed(() => userStore.username)

// Call actions
function fetchUserData() {
  userStore.fetchUser()
}

// Watch for store changes
watch(() => userStore.currentUser, (newUser) => {
  if (newUser) {
    console.log('User logged in:', newUser.name)
  }
})

// Use onMounted lifecycle hook to fetch data
onMounted(() => {
  if (!userStore.currentUser) {
    userStore.fetchUser()
  }
})
</script>

<template>
  <div>
    <p v-if="userStore.isLoading">Loading user...</p>
    <p v-else-if="userStore.error">Error: {{ userStore.error }}</p>
    <div v-else>
      <h2>Welcome, {{ username }}</h2>
      <button @click="userStore.logout">Logout</button>
    </div>
  </div>
</template>
```

## Store Organization and Design Principles

### 1. Store Naming

- Use the `use` prefix for store functions (e.g., `useUserStore`)
- Name store files after their domain (e.g., `user.ts`, `auth.ts`)

### 2. State Design

- Keep state normalized and flat when possible
- Use TypeScript interfaces to define state shape
- Initialize with sensible defaults
- Avoid redundant or derived data that can be computed

### 3. Getters

- Use getters for derived state
- Keep getters pure and focused
- Use TypeScript for better type inference
- Consider memoization for expensive computations

### 4. Actions

- Use actions for all state mutations
- Handle asynchronous operations in actions
- Implement proper error handling
- Use actions to coordinate complex state changes

### 5. Modules and Namespacing

- Divide large stores into logical domains
- Use Pinia's automatic namespacing
- Consider store composition for reusable store patterns

## Advanced Patterns

### 1. Store Composition

Compose stores to reuse functionality:

```typescript
// stores/features/todoList.ts
import { defineStore } from 'pinia'
import { useUserStore } from '../user'

export const useTodoStore = defineStore('todo', {
  state: () => ({
    todos: []
  }),
  
  actions: {
    async fetchTodos() {
      const userStore = useUserStore()
      if (!userStore.isLoggedIn) {
        throw new Error('User must be logged in')
      }
      
      // Fetch todos using the current user's ID
      const todos = await $fetch(`/api/users/${userStore.currentUser.id}/todos`)
      this.todos = todos
    }
  }
})
```

### 2. Store Reset

Reset store state when needed:

```typescript
// stores/index.ts
import { createPinia } from 'pinia'

export function resetStores() {
  const pinia = useNuxtApp().$pinia
  
  // Use $reset on all registered stores
  pinia._s.forEach((store) => {
    if (store.$reset) {
      store.$reset()
    }
  })
}
```

### 3. Store Persistence

Persist store state across page reloads:

```typescript
// plugins/pinia-persist.ts
import { defineNuxtPlugin } from 'nuxt/app'
import { createPinia } from 'pinia'
import { PiniaPluginContext } from 'pinia'

function piniaLocalStoragePlugin({ store }: PiniaPluginContext) {
  // Load persistent state when store is initialized
  const storedState = localStorage.getItem(`pinia-${store.$id}`)
  
  if (storedState) {
    store.$patch(JSON.parse(storedState))
  }
  
  // Save state whenever it changes
  store.$subscribe((mutation, state) => {
    localStorage.setItem(`pinia-${store.$id}`, JSON.stringify(state))
  })
}

export default defineNuxtPlugin(({ vueApp }) => {
  const pinia = createPinia()
  pinia.use(piniaLocalStoragePlugin)
  vueApp.use(pinia)
})
```

## Best Practices for Nuxt Applications

### 1. Hydration

Pinia works well with Nuxt's SSR and hydration process. To avoid hydration mismatches:

- Initialize stores with default values
- Handle undefined states gracefully
- Use `nuxt-app` plugin hooks for store initialization

### 2. Server-Side State

When using stores in SSR context:

```typescript
// Handle server-side state initialization
export const useProductStore = defineStore('products', {
  state: () => ({
    products: [],
    loaded: false
  }),
  
  actions: {
    async fetchProducts() {
      if (this.loaded) return
      
      const products = await $fetch('/api/products')
      this.products = products
      this.loaded = true
    }
  }
})
```

### 3. Type Safety

Leverage TypeScript for type-safe stores:

```typescript
// types/store.ts
export interface User {
  id: string
  firstName: string
  lastName: string
  email: string
  role: 'admin' | 'user'
}

export interface AuthState {
  user: User | null
  token: string | null
  isAuthenticated: boolean
  isLoading: boolean
  error: string | null
}
```

### 4. Testing Stores

Create testable stores:

```typescript
// tests/stores/user.test.ts
import { setActivePinia, createPinia } from 'pinia'
import { useUserStore } from '~/stores/user'
import { describe, beforeEach, it, expect, vi } from 'vitest'

describe('User Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })
  
  it('has correct initial state', () => {
    const store = useUserStore()
    expect(store.currentUser).toBe(null)
    expect(store.isLoading).toBe(false)
    expect(store.error).toBe(null)
  })
  
  it('updates user when fetchUser succeeds', async () => {
    const store = useUserStore()
    
    // Mock fetch
    global.$fetch = vi.fn().mockResolvedValue({
      id: '123',
      name: 'Test User',
      email: 'test@example.com'
    })
    
    await store.fetchUser()
    
    expect(store.isLoading).toBe(false)
    expect(store.currentUser).toEqual({
      id: '123',
      name: 'Test User',
      email: 'test@example.com'
    })
    expect(store.error).toBe(null)
  })
})
```

## Common Anti-patterns to Avoid

1. **Overusing Global State**: Not everything belongs in a store. Use stores for truly shared state.

2. **Direct State Mutation**: Always use actions to modify state for better predictability and debugging.

3. **Storing Derived Data**: Use getters instead of storing computed values in state.

4. **Lack of Typing**: Always use TypeScript interfaces to define store state shape.

5. **Circular Store Dependencies**: Avoid circular dependencies between stores.

This guide should help you implement robust and maintainable state management with Pinia in your Nuxt application.

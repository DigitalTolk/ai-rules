---
description: 
globs: 
alwaysApply: false
---
# Form Components Rule

## Description
This rule provides guidance for implementing forms using DigitalTolk UI form components. It covers form structure, validation, state management, and best practices.

## Available Form Components

### Input Components
- BaseTextField
- BaseInputNumber
- BaseSelect
- BaseDatePicker
- BaseTimepicker
- BaseLocationField
- BaseAutoComplete
- BaseTextEditor

### Selection Components
- BaseCheckbox
- BaseCheckboxGroup
- BaseRadio
- BaseRadioGroup
- BaseSwitch
- BaseRate

### File Upload
- BaseUpload

## Implementation Guidelines

### 1. Form Structure
```jsx
import { BaseForm } from '@digitaltolk/ui';

const MyForm = () => {
  return (
    <BaseForm
      layout="vertical"
      onFinish={handleSubmit}
      initialValues={initialData}
    >
      {/* Form fields */}
    </BaseForm>
  );
};
```

### 2. Form Fields
```jsx
// Text Input
<BaseTextField
  name="username"
  label="Username"
  required
  rules={[
    { required: true, message: 'Please enter username' },
    { min: 3, message: 'Username must be at least 3 characters' }
  ]}
/>

// Select
<BaseSelect
  name="country"
  label="Country"
  options={countryOptions}
  required
/>

// Date Picker
<BaseDatePicker
  name="birthDate"
  label="Birth Date"
  format="YYYY-MM-DD"
/>

// Checkbox Group
<BaseCheckboxGroup
  name="interests"
  label="Interests"
  options={interestOptions}
/>
```

### 3. Form Validation
```jsx
const validationRules = {
  email: [
    { required: true, message: 'Email is required' },
    { type: 'email', message: 'Invalid email format' }
  ],
  password: [
    { required: true, message: 'Password is required' },
    { min: 8, message: 'Password must be at least 8 characters' }
  ]
};
```

### 4. Form Submission
```jsx
const handleSubmit = async (values) => {
  try {
    await submitForm(values);
    BaseToaster.success('Form submitted successfully');
  } catch (error) {
    BaseToaster.error('Failed to submit form');
  }
};
```

## Best Practices

### 1. Form Layout
- Use consistent spacing between fields
- Group related fields together
- Use appropriate field sizes
- Implement responsive layouts

### 2. Validation
- Implement client-side validation
- Show clear error messages
- Validate on blur and submit
- Use appropriate validation rules

### 3. State Management
- Handle loading states
- Manage form errors
- Implement field-level validation
- Track form dirty state

### 4. Accessibility
- Use proper labels
- Implement keyboard navigation
- Add ARIA attributes
- Ensure proper focus management

### 5. Performance
- Debounce input handlers
- Optimize re-renders
- Use proper key props
- Implement proper cleanup

## Common Patterns

### 1. Dynamic Forms
```jsx
const DynamicForm = () => {
  const [fields, setFields] = useState([]);

  return (
    <BaseForm>
      {fields.map((field, index) => (
        <BaseTextField
          key={field.id}
          name={`field-${index}`}
          label={field.label}
        />
      ))}
    </BaseForm>
  );
};
```

### 2. Form with File Upload
```jsx
const FormWithUpload = () => {
  return (
    <BaseForm>
      <BaseTextField name="title" label="Title" />
      <BaseUpload
        name="documents"
        multiple
        maxCount={5}
        accept=".pdf,.doc,.docx"
      />
    </BaseForm>
  );
};
```

### 3. Form with Location Field
```jsx
const FormWithLocation = () => {
  return (
    <BaseForm>
      <BaseLocationField
        name="address"
        label="Address"
        required
        onLocationSelect={handleLocationSelect}
      />
    </BaseForm>
  );
};
```

## Error Handling

### 1. Form Level Errors
```jsx
<BaseForm
  onFinishFailed={({ errorFields }) => {
    BaseToaster.error('Please fix the errors in the form');
  }}
>
  {/* Form fields */}
</BaseForm>
```

### 2. Field Level Errors
```jsx
<BaseTextField
  name="email"
  validateStatus={errors.email ? 'error' : ''}
  help={errors.email}
/>
```

## Testing Checklist

- [ ] Form submission works correctly
- [ ] Validation rules are enforced
- [ ] Error messages are displayed properly
- [ ] Form state is managed correctly
- [ ] File uploads work as expected
- [ ] Form is accessible
- [ ] Form is responsive
- [ ] Form handles errors gracefully
- [ ] Form can be reset
- [ ] Form maintains state on navigation

## Notes
- Always use the BaseForm component as the form container
- Implement proper error handling
- Use appropriate validation rules
- Follow the design system guidelines
- Test all form scenarios
- Ensure accessibility compliance

---
description: 
globs: 
alwaysApply: false
---
# Nuxt 3 Project Structure
---
description: Guidelines for structuring Nuxt 3 projects with recommended architecture and conventions
glob: "**/*.{vue,ts,js}"
---

This guide outlines the recommended architecture, directory structure, and naming conventions for Nuxt 3 projects. Following these guidelines ensures a clean, maintainable, and scalable application.

## Directory Structure Overview

```
.
├── app/                 # (Optional) App directory if using new Nuxt 4-style structure
├── assets/              # Static assets to be processed
├── components/          # Vue components
│   ├── ui/              # Design system components
│   ├── common/          # App-wide reusable components
│   └── [feature]/       # Feature-specific components
├── composables/         # Vue composables (shared logic)
├── content/             # Markdown/MDC content (if using @nuxt/content)
├── layouts/             # Page layouts
├── middleware/          # Navigation middleware
├── pages/               # Application routes
│   └── [feature]/       # Feature-specific pages
├── plugins/             # Nuxt plugins
├── public/              # Static assets (unprocessed)
├── server/              # Server-side code
│   ├── api/             # API endpoints
│   ├── middleware/      # Server middleware
│   ├── routes/          # Custom server routes
│   └── utils/           # Server utilities
├── stores/              # Pinia stores
├── types/               # TypeScript type definitions
├── utils/               # Utility functions
├── app.vue              # App root component
├── app.config.ts        # App configuration
├── error.vue            # Error page
├── nuxt.config.ts       # Nuxt configuration
├── tsconfig.json        # TypeScript configuration
└── README.md            # Project documentation
```

## README Files

Each directory should contain a `README.md` file that explains:
- The purpose of the directory
- Organization guidelines
- Examples of usage
- Any conventions specific to that directory

## Naming Conventions

### Files and Directories

- **Components**: Use `PascalCase.vue` (e.g., `UserProfile.vue`)
- **Pages**: Use `kebab-case.vue` or `index.vue` (e.g., `user-profile.vue`)
- **Layouts**: Use `kebab-case.vue` (e.g., `default.vue`, `admin-layout.vue`)
- **Composables**: Use `camelCase.ts` with `use` prefix (e.g., `useAuth.ts`)
- **Store Files**: Use `camelCase.ts` (e.g., `user.ts`, `settings.ts`)
- **API Routes**: Use `kebab-case.ts` (e.g., `user-profile.ts`)
- **Utility Functions**: Use `camelCase.ts` (e.g., `formatDate.ts`)
- **Dynamic Routes**: Use `[param].vue` for dynamic segments (e.g., `[id].vue`)
- **Nested Dynamic Routes**: Use `_dir/[param].vue` pattern

### Component Names

- **Base/UI Components**: Prefix with appropriate namespace (e.g., `UiButton`, `BaseCard`)
- **Feature Components**: Group by feature/domain folder without special prefix
- **Page Components**: Can be prefixed with `Page` for clarity (e.g., `PageDashboard.vue`)
- **Layout Components**: Can be prefixed with `Layout` (e.g., `LayoutDefault.vue`)

## Directory-Specific Guidelines

### `components/`

- Group components by feature, domain, or type
- Create index files for batch imports when needed
- Keep components focused on a single responsibility
- Document props with JSDoc comments

```
components/
├── README.md
├── ui/                     # Design system components
│   ├── UiButton.vue
│   ├── UiCard.vue
│   └── ...
├── common/                 # App-wide reusable components
│   ├── AppHeader.vue
│   ├── AppFooter.vue
│   └── ...
└── dashboard/              # Feature-specific components
    ├── DashboardStats.vue
    ├── DashboardChart.vue
    └── ...
```

### `composables/`

- Focus on reusable, stateful logic
- Use the `use` prefix for all composables
- Split complex composables into multiple files
- Document parameters and return values

```
composables/
├── README.md
├── useAuth.ts
├── useUser.ts
├── useNotifications/
│   ├── index.ts
│   ├── types.ts
│   └── helpers.ts
└── ...
```

### `layouts/`

- Keep layouts focused on structure, not business logic
- Use slots for content injection
- Name default layout as `default.vue`

```
layouts/
├── README.md
├── default.vue
├── admin.vue
└── ...
```

### `pages/`

- Structure mirrors your URL routes
- Use index.vue for root routes
- Group related pages in directories
- Use dynamic parameters with `[param].vue` syntax

```
pages/
├── README.md
├── index.vue              # Home page
├── login.vue              # /login
├── dashboard/
│   ├── index.vue          # /dashboard
│   └── settings.vue       # /dashboard/settings
├── users/
│   ├── index.vue          # /users
│   └── [id].vue           # /users/:id
└── ...
```

### `server/`

- Organize by API resource or feature
- Use consistent error handling
- Document API endpoints

```
server/
├── README.md
├── api/
│   ├── auth.ts            # Authentication endpoints
│   ├── users.ts           # User-related endpoints
│   └── ...
├── middleware/
│   ├── auth.ts            # Authentication middleware
│   └── ...
└── utils/
    ├── db.ts              # Database utilities
    └── ...
```

### `stores/`

- Create one store per feature or domain
- Follow Pinia conventions
- Use TypeScript interfaces for state

```
stores/
├── README.md
├── user.ts
├── auth.ts
├── settings.ts
└── ...
```

### `public/`

- Only for files that need direct URL access
- Organize by file type
- Include README with usage instructions

```
public/
├── README.md
├── favicon.ico
├── robots.txt
├── images/
│   └── logo.png
└── ...
```

## Best Practices

1. **Auto-imports**: Leverage Nuxt's auto-import feature for components, composables and utilities
2. **Code Splitting**: Use async components for routes and large components
3. **Type Safety**: Use TypeScript throughout the application
4. **Consistent Component Structure**: Follow a consistent order for component options (script, template, style)
5. **Documentation**: Document complex logic, APIs, and component props

## SEO & Metadata

Use `useHead()` and `useSeoMeta()` composables to manage page metadata:

```typescript
useHead({
  title: 'Page Title',
  meta: [
    { name: 'description', content: 'Page description' }
  ],
  link: [
    { rel: 'icon', type: 'image/png', href: '/favicon.png' }
  ]
})
```

## Data Fetching

Use Nuxt's data fetching utilities consistently:

```typescript
// For page-level data
const { data } = await useFetch('/api/resource')

// For component-level data
const { data } = await useLazyFetch('/api/resource')

// For data with parameters
const { data } = await useAsyncData('key', () => $fetch('/api/resource'))
```

## Error Handling

Use consistent error handling patterns:

```typescript
try {
  const { data } = await useFetch('/api/resource')
} catch (error) {
  // Handle errors consistently
  useErrorHandler(error)
}
```

## Configuration

Keep sensitive configuration in environment variables and use Nuxt's runtime config:

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  runtimeConfig: {
    apiSecret: '', // Server-only
    public: {
      apiBase: '' // Available on client
    }
  }
})
```

## Deployment Structure

Document the deployment approach and any build-time considerations:

```
dist/                   # Production build output
├── _nuxt/              # Compiled assets
├── server/             # Server-side code
└── ...
```

## README Templates

For each directory, include a README.md with:

1. Purpose of the directory
2. Conventions specific to the directory
3. Examples of correct usage
4. Any special considerations

This structure and these conventions will ensure a consistent, maintainable Nuxt 3 application that leverages framework conventions while remaining flexible for project-specific needs.

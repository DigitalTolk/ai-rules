---
description: Data table component with sorting and pagination
globs: components/base/BaseTable.vue
alwaysApply: false
---

---
description: 
globs: 
alwaysApply: false
---
# BaseTable Component

## Description
BaseTable is a powerful data display component that provides features like sorting, filtering, pagination, and row selection. It's designed to handle large datasets efficiently and provides a rich set of customization options.

## Props

### Core Props
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| dataSource | any[] | [] | Data array to be displayed |
| columns | Column[] | [] | Configuration of table columns |
| loading | boolean | false | Loading state of table |
| pagination | boolean \| object | true | Pagination configuration |
| rowKey | string \| (record) => string | 'key' | Unique key for each row |
| scroll | { x?: number \| true, y?: number } | - | Table scroll configuration |
| size | 'small' \| 'middle' \| 'large' | 'middle' | Size of the table |
| bordered | boolean | false | Whether to show table border |
| rowSelection | object | - | Row selection configuration |

### Column Configuration
| Prop | Type | Description |
|------|------|-------------|
| title | ReactNode | Column title |
| dataIndex | string | Data field name |
| key | string | Unique key for column |
| render | (text, record, index) => ReactNode | Custom render function |
| sorter | boolean \| function | Sort configuration |
| filters | { text: string, value: string }[] | Filter options |
| onFilter | (value, record) => boolean | Filter function |
| width | number \| string | Column width |
| fixed | 'left' \| 'right' | Fixed column position |
| ellipsis | boolean | Whether to ellipsis cell content |

### Event Props
| Prop | Type | Description |
|------|------|-------------|
| onChange | (pagination, filters, sorter) => void | Triggered when table state changes |
| onRow | (record, index) => object | Row event handlers |
| onHeaderRow | (columns, index) => object | Header row event handlers |
| onExpand | (expanded, record) => void | Triggered when row is expanded |
| onSelect | (selectedRowKeys, selectedRows) => void | Triggered when row selection changes |

### Pagination Props
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| current | number | 1 | Current page number |
| pageSize | number | 10 | Number of items per page |
| total | number | 0 | Total number of items |
| showSizeChanger | boolean | false | Whether to show page size changer |
| showQuickJumper | boolean | false | Whether to show quick jumper |
| showTotal | (total, range) => string | - | Custom total text renderer |

## Examples

### Basic Usage
```jsx
import { BaseTable } from '@digitaltolk/ui';

const BasicTable = () => {
  const dataSource = [
    { id: 1, name: 'John', age: 32 },
    { id: 2, name: 'Jane', age: 28 },
  ];

  const columns = [
    { title: 'Name', dataIndex: 'name', key: 'name' },
    { title: 'Age', dataIndex: 'age', key: 'age' },
  ];

  return <BaseTable dataSource={dataSource} columns={columns} />;
};
```

### With Sorting and Filtering
```jsx
const AdvancedTable = () => {
  const columns = [
    {
      title: 'Name',
      dataIndex: 'name',
      key: 'name',
      sorter: (a, b) => a.name.localeCompare(b.name),
      filters: [
        { text: 'John', value: 'John' },
        { text: 'Jane', value: 'Jane' },
      ],
      onFilter: (value, record) => record.name === value,
    },
    {
      title: 'Age',
      dataIndex: 'age',
      key: 'age',
      sorter: (a, b) => a.age - b.age,
    },
  ];

  return (
    <BaseTable
      dataSource={dataSource}
      columns={columns}
      onChange={(pagination, filters, sorter) => {
        console.log('Table state changed:', { pagination, filters, sorter });
      }}
    />
  );
};
```

### With Row Selection
```jsx
const SelectableTable = () => {
  const [selectedRowKeys, setSelectedRowKeys] = useState([]);

  const rowSelection = {
    selectedRowKeys,
    onChange: (keys) => setSelectedRowKeys(keys),
  };

  return (
    <BaseTable
      dataSource={dataSource}
      columns={columns}
      rowSelection={rowSelection}
    />
  );
};
```

### With Custom Rendering
```jsx
const CustomTable = () => {
  const columns = [
    {
      title: 'Name',
      dataIndex: 'name',
      key: 'name',
      render: (text, record) => (
        <BaseLink href={`/users/${record.id}`}>{text}</BaseLink>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (status) => (
        <BaseTag color={status === 'active' ? 'green' : 'red'}>
          {status}
        </BaseTag>
      ),
    },
  ];

  return <BaseTable dataSource={dataSource} columns={columns} />;
};
```

### With Expandable Rows
```jsx
const ExpandableTable = () => {
  const expandedRowRender = (record) => (
    <div>
      <p>Additional details for {record.name}</p>
      <p>Email: {record.email}</p>
    </div>
  );

  return (
    <BaseTable
      dataSource={dataSource}
      columns={columns}
      expandable={{ expandedRowRender }}
    />
  );
};
```

## Best Practices

1. **Performance**
   - Use `rowKey` for efficient row identification
   - Implement virtual scrolling for large datasets
   - Use proper pagination settings
   - Optimize column rendering

2. **Data Handling**
   - Implement proper data loading states
   - Handle empty states gracefully
   - Implement proper error handling
   - Use appropriate data types

3. **User Experience**
   - Provide clear column headers
   - Implement proper sorting and filtering
   - Use appropriate column widths
   - Implement responsive design

4. **Accessibility**
   - Use proper ARIA labels
   - Ensure keyboard navigation
   - Maintain proper contrast
   - Provide screen reader support

## Common Patterns

### Server-side Pagination
```jsx
const ServerSideTable = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [pagination, setPagination] = useState({
    current: 1,
    pageSize: 10,
    total: 0,
  });

  const fetchData = async (params = {}) => {
    setLoading(true);
    try {
      const response = await fetchDataFromServer(params);
      setData(response.data);
      setPagination({
        ...pagination,
        total: response.total,
      });
    } catch (error) {
      BaseToaster.error('Failed to fetch data');
    } finally {
      setLoading(false);
    }
  };

  const handleTableChange = (pagination, filters, sorter) => {
    fetchData({
      page: pagination.current,
      pageSize: pagination.pageSize,
      sortField: sorter.field,
      sortOrder: sorter.order,
      ...filters,
    });
  };

  return (
    <BaseTable
      columns={columns}
      dataSource={data}
      pagination={pagination}
      loading={loading}
      onChange={handleTableChange}
    />
  );
};
```

### Editable Table
```jsx
const EditableTable = () => {
  const [dataSource, setDataSource] = useState([]);
  const [editingKey, setEditingKey] = useState('');

  const isEditing = (record) => record.key === editingKey;

  const edit = (record) => {
    setEditingKey(record.key);
  };

  const save = async (key) => {
    try {
      const row = await form.validateFields();
      const newData = [...dataSource];
      const index = newData.findIndex(item => key === item.key);
      if (index > -1) {
        const item = newData[index];
        newData.splice(index, 1, { ...item, ...row });
        setDataSource(newData);
        setEditingKey('');
      }
    } catch (errInfo) {
      console.log('Validate Failed:', errInfo);
    }
  };

  const columns = [
    {
      title: 'Name',
      dataIndex: 'name',
      editable: true,
    },
    {
      title: 'Action',
      dataIndex: 'action',
      render: (_, record) => {
        const editable = isEditing(record);
        return editable ? (
          <span>
            <BaseButton onClick={() => save(record.key)}>Save</BaseButton>
            <BaseButton onClick={() => setEditingKey('')}>Cancel</BaseButton>
          </span>
        ) : (
          <BaseButton disabled={editingKey !== ''} onClick={() => edit(record)}>
            Edit
          </BaseButton>
        );
      },
    },
  ];

  return <BaseTable dataSource={dataSource} columns={columns} />;
};
```

## Testing Checklist

- [ ] Table renders correctly with data
- [ ] Pagination works correctly
- [ ] Sorting works correctly
- [ ] Filtering works correctly
- [ ] Row selection works correctly
- [ ] Custom rendering works correctly
- [ ] Loading state works correctly
- [ ] Empty state is handled correctly
- [ ] Error state is handled correctly
- [ ] Accessibility features work
- [ ] Keyboard navigation works
- [ ] Responsive design works
- [ ] Performance is acceptable

## Notes
- Always provide proper row keys
- Handle loading and error states
- Implement proper pagination
- Use appropriate column configurations
- Follow the design system guidelines
- Test all table features
- Ensure proper accessibility
- Optimize performance for large datasets

# Best Coding Practices

## Overview
This rule defines best practices for writing maintainable, readable, and robust code across the codebase. It supplements existing rules for TypeScript, project structure, and component usage.

---

glob: "**/*.{js,ts,vue,tsx,jsx}"

description: Coding standards for maintainability, readability, and quality

---

## General Principles
- Write code that is easy to read, understand, and maintain.
- Prefer clarity over cleverness.
- Write self-documenting code: use meaningful names for variables, functions, and classes.
- Avoid deep nesting; refactor complex logic into smaller functions.
- Write DRY (Don't Repeat Yourself) code—extract reusable logic.

## Functional Programming
- Favor pure functions: functions should avoid side effects and always return the same output for the same input.
- Prefer immutability: avoid mutating input parameters or shared state.
- Use higher-order functions (map, filter, reduce) for collection transformations.
- Avoid shared mutable state; use local variables and return new objects/arrays.

## SOLID Principles
- **Single Responsibility Principle:** Each function, class, or module should have one responsibility.
- **Open/Closed Principle:** Code should be open for extension but closed for modification.
- **Liskov Substitution Principle:** Subtypes must be substitutable for their base types.
- **Interface Segregation Principle:** Prefer small, specific interfaces over large, general ones.
- **Dependency Inversion Principle:** Depend on abstractions, not concrete implementations.

## Function & File Size
- Functions should generally be no longer than 40 lines. If a function grows larger, refactor it into smaller helper functions.
- Files should generally not exceed 300 lines. Split large files into logical modules.
- Each function should do one thing and do it well.
- Avoid functions with high cyclomatic complexity (limit: 10). Refactor complex logic into smaller, simpler functions.

## Clean Code & Maintainability
- Avoid magic numbers and strings; use named constants.
- Write unit tests for critical logic and pure functions.
- Use comments to explain "why" something is done, not "what"—the code should show the "what".
- Remove dead code and unused variables.
- Prefer composition over inheritance.
- Use early returns to reduce nesting and improve readability.
- Handle errors gracefully and consistently.

## Code Reviews & Collaboration
- All code should be peer-reviewed before merging.
- Address review comments promptly and respectfully.
- Ask for help or clarification when unsure about best practices.

---

Adhering to these practices will help ensure a high-quality, maintainable codebase as the project grows.

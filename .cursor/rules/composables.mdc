---
description: When dealing with any composable creation, modification this rule should be used
globs: 
alwaysApply: false
---
# Vue Composables

Vue composables are reusable stateful logic functions that leverage Vue's Composition API. They are the equivalent of React hooks in the Vue ecosystem. This guide outlines best practices for writing and using composables in your Nuxt application.

## Directory Structure

```
composables/
├── README.md                   # Documentation
├── useAuth.ts                  # Authentication logic
├── useUser.ts                  # User-related operations
├── useNotifications.ts         # Notification functionality
├── useMediaQuery.ts            # Responsive design helpers
├── useDevice.ts                # Device detection
└── features/                   # Feature-specific composables
    ├── useCartActions.ts       # Cart operations
    └── useProductFilters.ts    # Product filtering logic
```

## Naming Conventions

- All composable files should start with the `use` prefix (e.g., `useAuth.ts`)
- Use camelCase for file naming
- Name composables based on their functionality, not implementation details
- For complex composables, create a directory with the same name and an index.ts file

## Basic Composable Structure

```typescript
// composables/useCounter.ts
import { ref, computed } from 'vue'

export function useCounter(initialValue = 0) {
  // State
  const count = ref(initialValue)
  
  // Actions
  function increment() {
    count.value++
  }
  
  function decrement() {
    count.value--
  }
  
  function reset() {
    count.value = initialValue
  }
  
  // Derived state
  const isPositive = computed(() => count.value > 0)
  const isNegative = computed(() => count.value < 0)
  const isZero = computed(() => count.value === 0)
  
  // Return exposed state and methods
  return {
    // State
    count,
    
    // Computed
    isPositive,
    isNegative,
    isZero,
    
    // Actions
    increment,
    decrement,
    reset
  }
}
```

## Using Composables in Components

```vue
<template>
  <div>
    <p>Count: {{ count }}</p>
    <p v-if="isPositive">The count is positive!</p>
    <p v-else-if="isNegative">The count is negative!</p>
    <p v-else>The count is zero!</p>
    
    <button @click="increment">Increment</button>
    <button @click="decrement">Decrement</button>
    <button @click="reset">Reset</button>
  </div>
</template>

<script setup>
import { useCounter } from '~/composables/useCounter'

// Destructure the composable return value
const { 
  count, 
  isPositive, 
  isNegative, 
  isZero, 
  increment, 
  decrement, 
  reset 
} = useCounter(10)
</script>
```

## Composable Design Patterns

### 1. State Management Composable

For managing and sharing state across components:

```typescript
// composables/useSharedState.ts
import { reactive, readonly } from 'vue'

const state = reactive({
  isModalOpen: false,
  theme: 'light',
  user: null
})

export function useSharedState() {
  function setTheme(newTheme) {
    state.theme = newTheme
  }
  
  function openModal() {
    state.isModalOpen = true
  }
  
  function closeModal() {
    state.isModalOpen = false
  }
  
  function setUser(user) {
    state.user = user
  }
  
  return {
    // Readonly state prevents direct mutation
    state: readonly(state),
    
    // Actions for controlled mutations
    setTheme,
    openModal,
    closeModal,
    setUser
  }
}
```

### 2. API Fetching Composable

For data fetching with loading and error handling:

```typescript
// composables/useApi.ts
import { ref, reactive } from 'vue'

export function useApi() {
  const isLoading = ref(false)
  const error = ref(null)
  const data = ref(null)
  
  async function fetchData(url, options = {}) {
    isLoading.value = true
    error.value = null
    
    try {
      const response = await $fetch(url, options)
      data.value = response
      return response
    } catch (err) {
      error.value = err.message || 'An error occurred'
      throw err
    } finally {
      isLoading.value = false
    }
  }
  
  return {
    isLoading,
    error,
    data,
    fetchData
  }
}

// Usage in a component
const { isLoading, error, data, fetchData } = useApi()
const users = ref([])

onMounted(async () => {
  try {
    users.value = await fetchData('/api/users')
  } catch (err) {
    console.error('Failed to fetch users:', err)
  }
})
```

### 3. Form Handling Composable

For managing form state and validation:

```typescript
// composables/useForm.ts
import { reactive, computed, ref } from 'vue'

export function useForm(initialValues = {}, validationRules = {}) {
  const values = reactive({ ...initialValues })
  const errors = reactive({})
  const touched = reactive({})
  
  // Track if form has been submitted
  const isSubmitted = ref(false)
  
  // Validate a single field
  function validateField(field) {
    const rule = validationRules[field]
    if (!rule) return true
    
    const value = values[field]
    const result = rule(value, values)
    
    if (result === true) {
      errors[field] = null
      return true
    } else {
      errors[field] = result
      return false
    }
  }
  
  // Validate all fields
  function validate() {
    let isValid = true
    
    for (const field in validationRules) {
      const fieldIsValid = validateField(field)
      isValid = isValid && fieldIsValid
      touched[field] = true
    }
    
    return isValid
  }
  
  // Handle input changes
  function handleChange(field, value) {
    values[field] = value
    if (touched[field]) {
      validateField(field)
    }
  }
  
  // Handle field blur
  function handleBlur(field) {
    touched[field] = true
    validateField(field)
  }
  
  // Reset form to initial values
  function reset() {
    for (const key in initialValues) {
      values[key] = initialValues[key]
    }
    
    for (const key in errors) {
      errors[key] = null
    }
    
    for (const key in touched) {
      touched[key] = false
    }
    
    isSubmitted.value = false
  }
  
  // Handle form submission
  async function handleSubmit(submitFn) {
    isSubmitted.value = true
    
    if (validate()) {
      try {
        return await submitFn(values)
      } catch (err) {
        throw err
      }
    }
  }
  
  // Form is valid if all fields validate
  const isValid = computed(() => {
    return Object.keys(validationRules).every(field => validateField(field))
  })
  
  return {
    values,
    errors,
    touched,
    isValid,
    isSubmitted,
    handleChange,
    handleBlur,
    reset,
    validate,
    handleSubmit
  }
}
```

### 4. Lifecycle Composable

For handling component lifecycle with cleanup:

```typescript
// composables/useInterval.ts
import { onMounted, onUnmounted } from 'vue'

export function useInterval(callback, delay) {
  let intervalId = null
  
  onMounted(() => {
    intervalId = setInterval(callback, delay)
  })
  
  onUnmounted(() => {
    clearInterval(intervalId)
  })
  
  // Return control functions
  return {
    clear: () => clearInterval(intervalId),
    reset: () => {
      clearInterval(intervalId)
      intervalId = setInterval(callback, delay)
    }
  }
}
```

### 5. Event Listener Composable

For managing DOM event listeners:

```typescript
// composables/useEventListener.ts
import { onMounted, onUnmounted } from 'vue'

export function useEventListener(target, event, callback, options = {}) {
  // Handle case where target might be a ref
  const getTarget = () => {
    return target.value ?? target
  }
  
  onMounted(() => {
    const targetElement = getTarget()
    if (!targetElement) return
    
    targetElement.addEventListener(event, callback, options)
  })
  
  onUnmounted(() => {
    const targetElement = getTarget()
    if (!targetElement) return
    
    targetElement.removeEventListener(event, callback, options)
  })
}
```

## Nuxt-Specific Composables

### 1. Route-Based Composables

Leverage Nuxt router integration:

```typescript
// composables/usePageNavigation.ts
import { useRouter, useRoute } from 'nuxt/app'

export function usePageNavigation() {
  const router = useRouter()
  const route = useRoute()
  
  // Navigate with query param preservation
  function navigateTo(path, preserveQuery = false) {
    if (preserveQuery) {
      router.push({
        path,
        query: route.query
      })
    } else {
      router.push(path)
    }
  }
  
  // Add query params to current route
  function addQueryParams(params) {
    router.push({
      path: route.path,
      query: {
        ...route.query,
        ...params
      }
    })
  }
  
  // Check if current route matches pattern
  const isActive = (pathPattern) => {
    return route.path.startsWith(pathPattern)
  }
  
  return {
    navigateTo,
    addQueryParams,
    isActive,
    currentPath: route.path,
    currentQuery: route.query
  }
}
```

### 2. SSR-Friendly Data Fetching

Using Nuxt's built-in data fetching utilities:

```typescript
// composables/useResource.ts
import { useAsyncData, useFetch } from '#app'

export function useResource(resourceType, id = null) {
  // Generate a unique key for this resource request
  const key = `${resourceType}${id ? `-${id}` : ''}`
  
  // Determine endpoint based on whether we have an ID
  const endpoint = id 
    ? `/api/${resourceType}/${id}`
    : `/api/${resourceType}`
  
  // Fetch the data using Nuxt's built-in composable
  const { 
    data, 
    pending, 
    error, 
    refresh 
  } = useAsyncData(key, () => $fetch(endpoint))
  
  // Helper for creating a new resource
  async function create(payload) {
    return await $fetch(`/api/${resourceType}`, {
      method: 'POST',
      body: payload
    })
  }
  
  // Helper for updating an existing resource
  async function update(payload) {
    if (!id) throw new Error('ID is required for update')
    
    return await $fetch(`/api/${resourceType}/${id}`, {
      method: 'PUT',
      body: payload
    })
  }
  
  // Helper for deleting a resource
  async function remove() {
    if (!id) throw new Error('ID is required for deletion')
    
    return await $fetch(`/api/${resourceType}/${id}`, {
      method: 'DELETE'
    })
  }
  
  return {
    data,
    isLoading: pending,
    error,
    refresh,
    create,
    update,
    remove
  }
}
```

### 3. Composable for Runtime Config

Access Nuxt's runtime config in a composable:

```typescript
// composables/useAppConfig.ts
import { useRuntimeConfig } from '#app'

export function useAppConfig() {
  const config = useRuntimeConfig()
  
  // Public config is safe to use in both client and server
  const publicConfig = config.public
  
  // Helper for determining environment
  const isDevelopment = process.dev
  const isProduction = !process.dev
  
  return {
    apiBaseUrl: publicConfig.apiBase,
    appName: publicConfig.appName,
    appVersion: publicConfig.version,
    isDevelopment,
    isProduction,
    // Add other frequently used config values
  }
}
```

## Testing Composables

Write tests for your composables to ensure their reliability:

```typescript
// tests/composables/useCounter.test.ts
import { useCounter } from '~/composables/useCounter'
import { describe, it, expect, beforeEach } from 'vitest'

describe('useCounter', () => {
  it('initializes with the default value', () => {
    const { count } = useCounter()
    expect(count.value).toBe(0)
  })
  
  it('initializes with a custom value', () => {
    const { count } = useCounter(10)
    expect(count.value).toBe(10)
  })
  
  it('increments the count', () => {
    const { count, increment } = useCounter(1)
    increment()
    expect(count.value).toBe(2)
  })
  
  it('decrements the count', () => {
    const { count, decrement } = useCounter(1)
    decrement()
    expect(count.value).toBe(0)
  })
  
  it('resets the count', () => {
    const { count, increment, reset } = useCounter(5)
    increment()
    expect(count.value).toBe(6)
    reset()
    expect(count.value).toBe(5)
  })
})
```

## Best Practices

1. **Single Responsibility**
   - Each composable should have a single, well-defined purpose
   - Break complex composables into smaller, focused ones

2. **Naming Conventions**
   - Always prefix with `use` to indicate it's a composable
   - Name should clearly reflect functionality
   - Use camelCase for all names

3. **Return Type**
   - Expose only what's needed by consumers
   - Group related functionality
   - Document returned properties and methods

4. **Documentation**
   - Document parameters, return values, and usage examples
   - Use TypeScript for better type safety

5. **State Management**
   - Be careful with global state in composables
   - Use readonly when exposing reactive state
   - Consider using Pinia for truly global state

6. **Error Handling**
   - Handle errors gracefully within composables
   - Provide error state that consumers can access
   - Document potential errors

7. **Reactivity**
   - Use `ref`, `reactive`, and `computed` appropriately
   - Return reactive references, not raw values
   - Be mindful of reactivity caveats

8. **Testing**
   - Write unit tests for composables
   - Test edge cases and error scenarios
   - Mock external dependencies

9. **SSR Compatibility**
   - Ensure composables work with Nuxt's SSR
   - Use `onServerPrefetch` for server-side data fetching
   - Be careful with browser-only APIs

10. **Auto-Imports**
    - Take advantage of Nuxt's auto-import feature
    - Organize composables logically in the composables/ directory
    - Use index.ts files for re-exports when appropriate

This guide should help you implement robust and maintainable composables in your Nuxt application.

---
description: 
globs: 
alwaysApply: false
---
# API Routes
---
description: Guidelines for implementing API routes in Nuxt application
glob: "**/server/api/**/*.{js,ts,vue}"
---

## Overview

This document outlines our conventions for implementing API routes in the Nuxt application. API routes provide server-side functionality that can be consumed by the frontend.

## Directory Structure

API routes are located in the `/server/api` directory. Each route is defined in a file that exports HTTP method handlers:

```
/server/api
  /user
    /profile.ts
    /preferences.ts
  /products
    /index.ts
    /[id].ts
  /orders
    /index.ts
    /[id].ts
    /status.ts
```

## Route Definition

API routes are defined using Nuxt's H3 server utilities:

```ts
// server/api/products/index.ts
import { defineEventHandler, getQuery } from 'h3'
import { z } from 'zod'
import { prisma } from '~/server/utils/prisma'

// GET /api/products
export default defineEventHandler(async (event) => {
  // Get query parameters
  const { limit = 20, offset = 0, category } = getQuery(event)
  
  // Validate query parameters
  const schema = z.object({
    limit: z.coerce.number().int().positive().lte(100).default(20),
    offset: z.coerce.number().int().min(0).default(0),
    category: z.string().optional(),
  })
  
  try {
    const validated = schema.parse({ limit, offset, category })
    
    // Build the query
    const where = validated.category ? { category: validated.category } : {}
    
    // Fetch data from the database
    const products = await prisma.product.findMany({
      where,
      take: validated.limit,
      skip: validated.offset,
      orderBy: { createdAt: 'desc' },
    })
    
    // Count total for pagination
    const total = await prisma.product.count({ where })
    
    return {
      products,
      pagination: {
        total,
        limit: validated.limit,
        offset: validated.offset,
      }
    }
  } catch (error) {
    // Handle validation errors
    if (error instanceof z.ZodError) {
      event.res.statusCode = 400
      return { error: 'Invalid request parameters', details: error.flatten() }
    }
    
    // Handle other errors
    console.error('Product API error:', error)
    event.res.statusCode = 500
    return { error: 'Internal server error' }
  }
})
```

## HTTP Methods

You can define handlers for different HTTP methods:

```ts
// server/api/products/[id].ts
import { defineEventHandler, getRouterParams, readBody } from 'h3'
import { z } from 'zod'
import { prisma } from '~/server/utils/prisma'

// GET /api/products/:id
export const GET = defineEventHandler(async (event) => {
  const { id } = getRouterParams(event)
  
  try {
    const product = await prisma.product.findUnique({
      where: { id },
    })
    
    if (!product) {
      event.res.statusCode = 404
      return { error: 'Product not found' }
    }
    
    return product
  } catch (error) {
    console.error('Product API error:', error)
    event.res.statusCode = 500
    return { error: 'Internal server error' }
  }
})

// PUT /api/products/:id
export const PUT = defineEventHandler(async (event) => {
  const { id } = getRouterParams(event)
  const body = await readBody(event)
  
  // Validate the request body
  const schema = z.object({
    name: z.string().min(1).max(100).optional(),
    price: z.number().positive().optional(),
    description: z.string().optional(),
    category: z.string().optional(),
  })
  
  try {
    const validated = schema.parse(body)
    
    const product = await prisma.product.update({
      where: { id },
      data: validated,
    })
    
    return product
  } catch (error) {
    // Handle validation errors
    if (error instanceof z.ZodError) {
      event.res.statusCode = 400
      return { error: 'Invalid request body', details: error.flatten() }
    }
    
    // Handle not found
    if (error.code === 'P2025') {
      event.res.statusCode = 404
      return { error: 'Product not found' }
    }
    
    // Handle other errors
    console.error('Product API error:', error)
    event.res.statusCode = 500
    return { error: 'Internal server error' }
  }
})

// DELETE /api/products/:id
export const DELETE = defineEventHandler(async (event) => {
  const { id } = getRouterParams(event)
  
  try {
    await prisma.product.delete({
      where: { id },
    })
    
    event.res.statusCode = 204
    return null
  } catch (error) {
    // Handle not found
    if (error.code === 'P2025') {
      event.res.statusCode = 404
      return { error: 'Product not found' }
    }
    
    // Handle other errors
    console.error('Product API error:', error)
    event.res.statusCode = 500
    return { error: 'Internal server error' }
  }
})
```

## Authentication and Authorization

For protected routes, use middleware to handle authentication:

```ts
// server/api/user/profile.ts
import { defineEventHandler, getSession } from 'h3'
import { prisma } from '~/server/utils/prisma'

export default defineEventHandler(async (event) => {
  // Get the user session
  const session = await getSession(event)
  
  // Check if the user is authenticated
  if (!session || !session.user) {
    event.res.statusCode = 401
    return { error: 'Unauthorized' }
  }
  
  // Fetch the user profile
  try {
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        name: true,
        email: true,
        image: true,
        createdAt: true,
        preferences: true,
      },
    })
    
    if (!user) {
      event.res.statusCode = 404
      return { error: 'User not found' }
    }
    
    return user
  } catch (error) {
    console.error('User API error:', error)
    event.res.statusCode = 500
    return { error: 'Internal server error' }
  }
})
```

## File Uploads

For handling file uploads:

```ts
// server/api/upload.ts
import { defineEventHandler, readMultipartFormData } from 'h3'
import { writeFile } from 'fs/promises'
import { join } from 'path'
import { randomUUID } from 'crypto'

export const POST = defineEventHandler(async (event) => {
  try {
    const formData = await readMultipartFormData(event)
    
    if (!formData || !formData.length) {
      event.res.statusCode = 400
      return { error: 'No file uploaded' }
    }
    
    const file = formData.find(item => item.name === 'file')
    
    if (!file) {
      event.res.statusCode = 400
      return { error: 'No file field in form data' }
    }
    
    // Generate a unique filename
    const filename = `${randomUUID()}-${file.filename}`
    const uploadDir = join(process.cwd(), 'public', 'uploads')
    const filepath = join(uploadDir, filename)
    
    // Write the file to disk
    await writeFile(filepath, file.data)
    
    // Return the file URL
    return {
      filename,
      url: `/uploads/${filename}`,
      size: file.data.length,
      type: file.type,
    }
  } catch (error) {
    console.error('Upload API error:', error)
    event.res.statusCode = 500
    return { error: 'Internal server error' }
  }
})
```

## Error Handling

Use consistent error handling across API routes:

```ts
// server/utils/api-error.ts
export class ApiError extends Error {
  constructor(
    public statusCode: number,
    message: string,
    public details?: any
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

// In your API route
import { defineEventHandler } from 'h3'
import { ApiError } from '~/server/utils/api-error'

export default defineEventHandler(async (event) => {
  try {
    // Your logic here
    
    // Throw an API error when needed
    if (!someCondition) {
      throw new ApiError(400, 'Invalid request', { field: 'Missing required field' })
    }
    
    return { success: true }
  } catch (error) {
    // Handle API errors
    if (error instanceof ApiError) {
      event.res.statusCode = error.statusCode
      return {
        error: error.message,
        details: error.details,
      }
    }
    
    // Handle unexpected errors
    console.error('API error:', error)
    event.res.statusCode = 500
    return { error: 'Internal server error' }
  }
})
```

## Best Practices

1. **Validation**: Always validate input data using a schema validation library like Zod.
2. **Error Handling**: Use consistent error handling with appropriate HTTP status codes.
3. **Authentication**: Protect sensitive routes with authentication checks.
4. **Performance**: Use pagination for large data sets and limit responses to necessary fields.
5. **Logging**: Log API errors with enough context for debugging.
6. **Security**: Sanitize inputs and avoid exposing sensitive data.
7. **Documentation**: Document your API endpoints with OpenAPI/Swagger when possible.

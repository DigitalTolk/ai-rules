# TypeScript Usage Rule

## Mandatory TypeScript Usage

TypeScript **must** be used for the following parts of the codebase:
- `apiServices` (API service files and modules)
- All network call logic (including fetchers, API clients, and related utilities)
- Backend data models, types, and interfaces
- Composables (Vue/React composables, hooks, or similar abstractions)
- Stores (state management, e.g., Pinia, Redux, Zustand, etc.)

> **Note:** TypeScript is **recommended but not enforced** for other files such as UI components, pages, and miscellaneous scripts. These may use JavaScript if necessary for rapid prototyping or third-party compatibility.

## Best Practices & Standards

### General
- Always use `.ts` or `.tsx`/`.vue` (with `<script lang="ts">`) extensions for TypeScript files.
- Prefer explicit types and interfaces over implicit `any`.
- Avoid using `any` unless absolutely necessary. Use `unknown` or more specific types when possible.
- Use type inference where it improves readability, but always type function arguments and return values in public APIs.
- Use enums or union types for fixed sets of values.
- Organize types and interfaces in a dedicated `types/` or `@types/` directory if shared across modules.

### API Services & Network Calls
- Define request and response types for all API calls.
- Use generics for reusable API utilities (e.g., `fetcher<T>`).
- Validate and transform API responses to match expected types.
- Document all public types and interfaces with JSDoc comments.

### Backend Data
- Define all data models and DTOs (Data Transfer Objects) with TypeScript interfaces or types.
- Use strict typing for all backend logic, including database access and business logic layers.

### Composables & Stores
- Always type composable return values and arguments.
- For stores, define a clear state interface/type and use it throughout the store implementation.
- Use TypeScript for actions, getters, and mutations (where applicable).

### Linting & Tooling
- Enforce TypeScript rules via ESLint/TSLint and CI.
- Use strict mode in `tsconfig.json` (`strict: true`).
- Keep dependencies up to date and avoid deprecated TypeScript features.

### Migration & Legacy Code
- Gradually migrate legacy JavaScript files to TypeScript as they are touched or refactored.
- Add type definitions for third-party libraries as needed (`@types/` packages).

---

For more, see the @TypeScript Handbook and your project's `tsconfig.json` for configuration standards.

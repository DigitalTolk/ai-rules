---
description: Guidelines for implementing Next.js server actions
globs: 
alwaysApply: false
---
# Nuxt Server Routes

## Format and Structure
Server routes in Nuxt 3 should follow this format:

Files:
- `server/api/NAME.validation.ts` - Validation schemas
- `server/api/NAME.ts` or `server/api/NAME/index.ts` - API endpoint handler

For `server/api/NAME.validation.ts`:

```typescript
import { z } from "zod";

// Example: Schema for updating AI settings
export const saveAiSettingsSchema = z.object({
  aiProvider: z.string().optional(), // Adjust types as needed
  aiModel: z.string().optional(),
  aiApiKey: z.string().optional(),
});
export type SaveAiSettingsBody = z.infer<typeof saveAiSettingsSchema>;

// Example: Schema for updating email settings
export const saveEmailUpdateSettingsSchema = z.object({
  statsEmailFrequency: z.string().optional(), // Use specific enum/types if applicable
  summaryEmailFrequency: z.string().optional(),
});
export type SaveEmailUpdateSettingsBody = z.infer<
  typeof saveEmailUpdateSettingsSchema
>;
```

For `server/api/settings.post.ts`:

```typescript
import { saveAiSettingsSchema, saveEmailUpdateSettingsSchema } from './settings.validation';
import { createError, defineEventHandler, readBody, getRouterParam } from 'h3';
import { prisma } from '@/server/utils/prisma';
import { withAuth } from '@/server/utils/auth';

export default defineEventHandler(async (event) => {
  // Apply auth middleware
  const { userId } = await withAuth(event);
  
  // Get request body and validate with Zod
  const body = await readBody(event);
  
  // Determine which action to perform based on request path or body parameters
  const action = event.path.includes('/ai-settings') ? 'updateAiSettings' : 'updateEmailSettings';
  
  try {
    if (action === 'updateAiSettings') {
      // Validate with Zod
      const validatedData = saveAiSettingsSchema.parse(body);
      
      // Update user AI settings
      await prisma.user.update({
        where: { id: userId },
        data: {
          aiProvider: validatedData.aiProvider,
          aiModel: validatedData.aiModel,
          aiApiKey: validatedData.aiApiKey
        },
      });
      
      return { success: true };
    } else {
      // Get the email account ID from the request
      const emailAccountId = getRouterParam(event, 'emailAccountId');
      if (!emailAccountId) {
        throw createError({
          statusCode: 400,
          message: 'Email account ID is required'
        });
      }
      
      // Validate with Zod
      const validatedData = saveEmailUpdateSettingsSchema.parse(body);
      
      // Update email settings
      await prisma.emailAccount.update({
        where: { id: emailAccountId },
        data: {
          statsEmailFrequency: validatedData.statsEmailFrequency,
          summaryEmailFrequency: validatedData.summaryEmailFrequency,
        },
      });
      
      return { success: true };
    }
  } catch (error) {
    if (error.name === 'ZodError') {
      throw createError({
        statusCode: 400,
        message: 'Validation error',
        data: error.format()
      });
    }
    
    console.error(`[${action}]`, error);
    throw createError({
      statusCode: 500,
      message: 'Server error occurred'
    });
  }
});
```

## Implementation Guidelines

- **File Organization:**
  - Create API routes in the `server/api/` directory
  - Use the `.get.ts`, `.post.ts`, `.put.ts`, etc. suffix for method-specific handlers
  - For complex endpoints, use a directory structure with `index.ts` and method-specific files

- **Authentication:**
  - Create a reusable auth middleware in `server/utils/auth.ts`
  - Wrap handlers with authentication using `withAuth` for protected routes
  - Return user context (userId, email, roles) from auth middleware

- **Input Validation:**
  - Define validation schemas using Zod in dedicated `.validation.ts` files
  - Validate request bodies using schema parsing
  - Return structured validation errors to the client

- **Error Handling:**
  - Use Nuxt's `createError` function for standardized error responses
  - Return appropriate HTTP status codes
  - Implement centralized error logging
  - Return structured error information in development, sanitized in production

- **Mutations vs Queries:**
  - Use appropriate HTTP methods (GET for queries, POST/PUT/DELETE for mutations)
  - Implement idempotent operations where possible
  - Return consistent response structures

- **Cache Control:**
  - Set appropriate cache headers for GET requests
  - Use `useNuxtApp().$fetch()` to make client-side requests with proper cache invalidation
  - Implement cache invalidation strategies for mutating operations

- **Monitoring and Logging:**
  - Add structured logging for all API operations
  - Trace request lifecycles
  - Implement performance monitoring